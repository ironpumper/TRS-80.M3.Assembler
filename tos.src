°°°±°	;	ROM AND TRSDOS CALLS°°°²°	;	ROM CALLS°°°³°	RESET	EQU	0000H°°°´°	KBCHAR	EQU	002BH°°°µ°	VDCHAR	EQU	0033H°°°¶°	PRCHAR	EQU	003BH°°°·°	LINPUT	EQU	0040H°°°¸°	KBWAIT	EQU	0049H°°°¹°	RSRCV	EQU	0050H°°±°°	RSTX	EQU	0055H°°±±°	RSINIT	EQU	005AH°°±²°	DELAY	EQU	0060H°°±³°	INITIO	EQU	0069H°°±´°	ROUTE	EQU	006CH°°±µ°	CLS	EQU	01C9H°°±¶°	PRSCN	EQU	01D9H°°±·°	CSOFF	EQU	01F8H°°±¸°	VDLINE	EQU	021BH°°±¹°	CSIN	EQU	0235H°°²°°	CSOUT	EQU	0264H°°²±°	CSHWR	EQU	0287H°°²²°	KBBRK	EQU	028DH°°²³°	CSHIN	EQU	0296H°°²´°	CLKON	EQU	0298H°°²µ°	CLKOFF	EQU	02A1H°°²¶°	READY	EQU	1A19H°°²·°	DATE	EQU	3033H°°²¸°	TIME	EQU	3036H°°²¹°	SETCAS	EQU	3042H°°³°°	PRSTAT	EQU	37E8H°°³±°	;	TRSDOS CALLS°°³²°	INIT	EQU	4420H		;Create a file°°³³°	OPEN	EQU	4424H°°³´°	POSN	EQU	4442H°°³µ°	READ	EQU	4436H°°³¶°	WRITE	EQU	4439H°°³·°	VERF	EQU	443CH°°³¸°	PUTEXT	EQU	444BH°°³¹°	BKSPC	EQU	4445H°°´°°	REWIND	EQU	443FH°°´±°	POSEOF	EQU	4448H°°´²°	SYNTAX	EQU	441CH°°´³°	DIVIDE	EQU	4451H°°´´°	DMULT	EQU	444EH°°´µ°	RAMDIR	EQU	4290H°°´¶°	FILPTR	EQU	428DH°°´·°	CLOSE	EQU	4428H°°´¸°	KILL	EQU	442CH°°´¹°	JP2DOS	EQU	402DH°°µ°°	ERRDSP	EQU	4409H°°µ±°	DSPDIR	EQU	4419H°°µ²°	COMDOS	EQU	4299H		;Exits to TRSDOS READY°°µ³°	CMDDOS	EQU	429CH		;returns to caller°°µ´°	CMDTXT	EQU	4225H		;Get common core°°µµ°	MEMEND	EQU	4411H°°µ¶°	;	End of rom & TRSDOS calls.°°µ·°	;°°µ¸°	;°°µ¹°	;°°¶°°	;		Program	:	TOS°°¶±°	;		Author	:	John Orlowski°°¶²°	;		Date	:	05-May-82°°¶³°	;		System	:	TRS-80 MOD III 32K°°¶´°	;°°¶µ°	;		THIS IS A TAPE OPERATING SYSTEM°°¶¶°	;		 Copyright (c) 1982 By John Orlowski°°¶·°	;		====================================°°¶¸°	;°°¶¹°	;		Enhanced to have disk operations°°·°°	;			by°°·±°	;		   John C. Orlowski°°·²°	;°°·³°	;°°·´°	;°°·µ°		ORG	0A000H	;TOP OF MEM°°·¶°	CPRGHT	DEFM	'Tape operating system (TOS) Version 1.0'°°··°		DEFB	0DH°°·¸°		DEFM	'Copyright (c) 1982 by John C. Orlowski'°°·¹°		DEFB	0DH°°¸°°		DEFM	'All rights reserved.'°°¸±°		DEFB	0DH°°¸²°	PRMPT	DEFM	'Tos  >  '°°¸³°		DEFB	03H		;TERMINATOR°°¸´°	ILLCMD	DEFM	'Illegal command'°°¸µ°		DEFB	0DH°°¸¶°	HLPMSG	DEFM	'C nnnn		Call address nnnn'°°¸·°		DEFB	0DH°°¸¸°		DEFM	'J nnnn		Jump to nnnn'°°¸¹°		DEFB	0DH°°¹°°		DEFM	'P nnnn		Print memory location nnnn'°°¹±°		DEFB	0DH°°¹²°		DEFM	'M nnnn dd	Deposit dd in location nnnn'°°¹³°		DEFB	0DH°°¹´°		DEFM	'D		Go back to debug'°°¹µ°		DEFB	0DH°°¹¶°		DEFM	'R ddss		route I/O from ss to dd'°°¹·°		DEFB	0DH°°¹¸°		DEFM	'		dd,ss= (KI/DO/RO/RI/PR)'°°¹¹°		DEFB	0DH°±°°°		DEFM	'I		initialize I/O drivers'°±°±°		DEFB	0DH°±°²°		DEFM	'L		look at registers'°±°³°		DEFB	0DH°±°´°		DEFM	'T		Load tape into memory'°±°µ°		DEFB	0DH°±°¶°		DEFM	'H		This help message'°±°·°		DEFB	0DH°±°¸°		DEFM	'W s e en nm	Write this to tape'°±°¹°		DEFB	0DH°±±°°		DEFM	'		s=start e=end en=entry n=name'°±±±°		DEFB	0DH°±±²°		DEFM	'&		Execute rest of line as TRSDOS command.'°±±³°		DEFB	0DH°±±´°	REGLBL	DEFM	' AF   BC   DE   HL   AF`  BC`  DE`  HL`'°±±µ°		DEFM	'  IX   IY   SP'°±±¶°		DEFB	0DH°±±·°	CASMS1	DEFM	'Checksum error'°±±¸°		DEFB	0DH°±±¹°	CASMS2	DEFM	'Start in memory: '°±²°°	CAS1	DEFS	4°±²±°		DEFM	'  End in memory: '°±²²°	CAS2	DEFS	4°±²³°		DEFM	'  Entry address: '°±²´°	CAS3	DEFS	4°±²µ°		DEFB	0DH°±²¶°	CASMS5	DEFM	'Incorrect tape format'°±²·°		DEFB	0DH°±²¸°	CASABO	DEFM	'Tape write aborted..'°±²¹°		DEFB	0DH°±³°°	ERRTXT	DEFM	'Invalid hex digit'°±³±°		DEFB	0DH°±³²°	;	C O M M A N D   T A B L E°±³³°	ADRTBL	DEFB	0DH		;<ENTER> NOTHING°±³´°		DEFW	RENTER		;SO LETS DO NOTHING°±³µ°		DEFB	'D'		;DEBUG°±³¶°		DEFW	DEBUG°±³·°		DEFB	'C'		;CALL°±³¸°		DEFW	CALL°±³¹°		DEFB	'J'		;(J)ump°±´°°		DEFW	JUMP°±´±°		DEFB	'M'		;MODIFY°±´²°		DEFW	MODIFY°±´³°		DEFB	'P'		;PRINT MEMORY°±´´°		DEFW	DSPMEM°±´µ°		DEFB	'R'		;(R)oute I/O°±´¶°		DEFW	ROUT°±´·°		DEFM	'I'		;INITIALIZE I/O°±´¸°		DEFW	INITDR°±´¹°		DEFM	'H'		;HELP°±µ°°		DEFW	HELP°±µ±°		DEFM	'L'		;(L)ook at reg.°±µ²°		DEFW	REGPNT°±µ³°		DEFM	'T'		;(T)ape load°±µ´°		DEFW	TLOAD°±µµ°		DEFM	'W'		;(W)rite tape°±µ¶°		DEFW	TWRITE°±µ·°		DEFM	'&'°±µ¸°		DEFW	TRSDOS°±µ¹°		DEFB	'!'		;COMMENTS°±¶°°		DEFW	RENTER°±¶±°		DEFB	'Q'°±¶²°		DEFW	JP2DOS		;Quit to trsdos°±¶³°	;°±¶´°	;	S T A R T   O F   P R O G R A M°±¶µ°	;°±¶¶°	TINIT	CALL	CLS		;CLEAR SCREEN°±¶·°		LD	HL,CPRGHT	;POINT TO MESSAGES°±¶¸°		LD	B,3		;3 messages°±¶¹°	INTMES	CALL	VDLINE		;PRINT OUT°±·°°		DJNZ	INTMES°±·±°	RENTER	LD	A,(4023)	;LSB of cursor°±·²°		AND	63		;is it on first position°±·³°		JP	Z,PRPRMT	;if so then skip ln feed°±·´°		LD	A,0AH		;<LF>°±·µ°		CALL	VDCHAR°±·¶°	PRPRMT	LD	HL,PRMPT	;'*'°±··°		CALL	VDLINE		;DISPLAY PROMPT°±·¸°		LD	HL,INPBUF°±·¹°		LD	DE,INPBUF+1	;FILL INP BUF WITH <ETX>°±¸°°		LD	BC,255°±¸±°		LD	(HL),03H	;<ETX>°±¸²°		LDIR			;FILL IT°±¸³°		LD	B,255		;MAX 255 CHARS°±¸´°		LD	HL,INPBUF	;POINT TO INPUT BUF°±¸µ°		LD	(WKSPCE),HL	;RST BUF POINTER°±¸¶°		CALL	LINPUT		;GET LINE°±¸·°	;°±¸¸°	;	Check for '&' if so then skip crunch°±¸¹°	;°±¹°°		LD	HL,INPBUF°±¹±°		LD	A,'&'°±¹²°		LD	BC,255°±¹³°		CPIR			;Is it there?°±¹´°		JP	Z,SCRNCH	;If so then Skip crunch°±¹µ°		LD	HL,INPBUF°±¹¶°		LD	DE,INPBUF	;LETS GET RID OF SPACES°±¹·°		CALL	CRUNCH		;SMOOSH!!!°±¹¸°	SCRNCH	LD	HL,INPBUF	;NOW CONVERT LC TO UC°±¹¹°		CALL	CVTUPC		;CONVERT IT°²°°°	INTRPT	LD	HL,(WKSPCE)	;LD OLD HL°²°±°		LD	A,(HL)		;GET 1'ST BYTE°²°²°		LD	C,15		;13 COMMANDS °²°³°		LD	DE,3		;KEY+ADDR = LENGTH°²°´°		LD	HL,ADRTBL	;POINT TO THE ADDR TBL°²°µ°		CALL	SEARCH		;SEARCH FOR CHARACTER°²°¶°		JR	NZ,ILLCOM	;SKIP THIS IF NOT FOUND°²°·°		INC	HL		;INCREMENT HL°²°¸°		LD	E,(HL)		;GET LSB°²°¹°		INC	HL		;INC HL°²±°°		LD	D,(HL)		;GET MSB°²±±°		LD	HL,(WKSPCE)	;GET OLD HL°²±²°		INC	HL		;ADD CMD LENTH°²±³°		LD	(WKSPCE),HL	;SAVE NEW POINTER°²±´°		EX	DE,HL		;EXCHANGE HL,DE°²±µ°		JP	(HL)		;GO AND DO SOMETHING°²±¶°	ILLCOM	LD	HL,ILLCMD	;POINT TO ILLEGAL COMMAND°²±·°		CALL	VDLINE		;PRINT IT°²±¸°		JR	RENTER		;BACK AGAIN°²±¹°	;°²²°°	;	16 * 8 BIT MULTIPLICATION°²²±°	;	ENTRY DE, AND B HAVE UNSIGNED NUMBERS°²²²°	;°²²³°	;	EXIT DE = PRODUCT, NO CHECK IS MADE FOR OVERFLOW°²²´°	;		CALL MULT°²²µ°	MULT	LD	HL,0		;CLEAR PARTIAL PRODUCT°²²¶°	LL1	SRL	B		;SHIFT OUT M'IER BIT°²²·°		JR	NC,CNT		;GO IF NO CARRY°²²¸°		ADD	HL,DE		;ADD MULTIPLICAND°²²¹°	CNT	RET	Z		;GO IF M'IER°²³°°		EX	DE,HL		;MUTIPLICAND TO HL°²³±°		ADD	HL,HL		;SHIFT MULTIPLICAND°²³²°		EX	DE,HL		;SWAP BACK°²³³°		JR	LL1		;CONTINUE°²³´°	;°²³µ°	;	DIVIDE 8 BY 8 BITS°²³¶°	;	ENTRY	E=DIVIDEND	C=DIVISIOR°²³·°	;	EXIT	A=QUOTIENT	B=REMAINDER°²³¸°	;°²³¹°	DIV8B8	XOR	A		;ZERO ACCUM°²´°°		LD	B,8		;B BITS°²´±°	LOOOOP	RL	E		;ROTATE CARRY OUT°²´²°		RLA			;GET CARRY°²´³°		SUB	C		;WILL IT GO°²´´°		JR	NC,CONTIN°²´µ°		ADD	A,C		;IF IT DIDN'T RESTORE IT°²´¶°	CONTIN	DJNZ	LOOOOP		;CONTINUE FOR 8 B'S°²´·°		LD	B,A		;PUT REMAINDER IN B°²´¸°		LD	A,E		;GET  QUOTIENT°²´¹°		RLA			;SHIFT IN LAST RESULT BIT°²µ°°		CPL			;COMPLIMENT BITS°²µ±°		RET°²µ²°	;	SUBROUTINE TO DIV 16/16°²µ³°	;	ENTRY DIVDND = AC DIVISOR = DE°²µ´°	;	EXIT QUOTIENT =AC REMAINDER = HL°²µµ°	DIV16	LD	HL,0°²µ¶°		LD	B,16°²µ·°	DIVLOP	RL	C°²µ¸°		ADC	HL,HL°²µ¹°		SBC	HL,DE°²¶°°		JR	NC,$+3°²¶±°		ADD	HL,DE°²¶²°		CCF°²¶³°		DJNZ	DIVLOP°²¶´°		RL	C°²¶µ°		RLA°²¶¶°		RET°²¶·°	;°²¶¸°	;	SET AND RESET DOT SUBROUTINES°²¶¹°	;	ENTRY	:	(DE)=Y,X COORDINATES OF POINT°²·°°	;		CALL	SET°²·±°	;		CALL	RESET°²·²°	;		CALL	TEST	;TEST POINT RTNS Z FLAG°²·³°	;	EXIT	A-L DESTROYED°²·´°	;°²·µ°	SET	LD	A,0C6H		;SET B,(HL) INSTRUCTION°²·¶°		JR	TEST10		;GO TO STORE°²··°	DRESET	LD	A,86H		;RES B,(HL) INSTRUCTION°²·¸°		JR	TEST10		;GO TO STORE°²·¹°	TEST	LD	A,46H		;BIT B,(HL) INSTRUCTION°²¸°°	TEST10	LD	(INST+1),A	;STORE 2ND BYTE°²¸±°	ADDRES	LD	A,D		;GET Y°²¸²°		LD	B,0FFH		;-1°²¸³°	LOP	INC	B		;SUCCESIVE SUBS FOR DIV°²¸´°		SUB	3		;BY THREE°²¸µ°		JP	P,LOP		;GO IF NOT MINUS°²¸¶°		ADD	A,3		;YQ IN B, YR IN A°²¸·°		SLA	A		;YR*2°²¸¸°		LD	C,A		;SAVE YR*2°²¸¹°		LD	L,B		;YQ TO L°²¹°°		LD	H,0		;YQ IN HL°²¹±°		LD	B,6		;CNT FOR MULTIPLY BY 64°²¹²°	LOP1	ADD	HL,HL		;YQ*2°²¹³°		DJNZ	LOP1		;GO IF NOT YQ*64°²¹´°		LD	D,0		;DE NOW HAS X°²¹µ°		SRL	E		;X Q°²¹¶°		JR	NC,LOP4		;GO IF XR NE1°²¹·°		INC	C		;C NOW HAS YR*2+XR°²¹¸°	LOP4	ADD	HL,DE		;HL NOW HAS YQ*2+XQ°²¹¹°		LD	DE,3C00H	;BASE VIDEO ADDR°³°°°		ADD	HL,DE		;HL NOW HAS ADDR°³°±°		SLA	C		;ALIGN TO FIELD°³°²°		SLA	C°³°³°		SLA	C°³°´°		LD	A,(INST+1)	;GET INSTRUCTION°³°µ°		ADD	A,C		;ALIGN FIELD°³°¶°		LD	(INST+1),A	;STORE°³°·°	INST	DEFB	0CBH		;PERFORM BIT,SET,RES°³°¸°		DEFB	0		;WILL BE FILLED IN°³°¹°		SET	7,(HL)		;BIT 7 FOR GRAPHICS°³±°°		RET			;DONE (FINALLY)°³±±°	;°³±²°	;	SUBROUTINES°³±³°	;°³±´°	;	SAVES ALL REGISTERS ON STACK°³±µ°	SAVE	PUSH	BC		;STORE°³±¶°		PUSH	AF		;AF°³±·°		POP	BC		;TO MEM°³±¸°		LD	(REG),BC°³±¹°		POP	BC		;GET REAL BC BACK°³²°°		LD	(REG+2),BC	;STORE REGS IN MEM°³²±°		LD	(REG+4),DE°³²²°		LD	(REG+6),HL°³²³°		EX	AF,AF'		;SWAP AF°³²´°		PUSH	AF		;SAVE AF' TO MEM°³²µ°		POP	BC°³²¶°		LD	(REG+8),BC°³²·°		EXX			;LETS SAVE PRIME NOW°³²¸°		LD	(REG+10),BC°³²¹°		LD	(REG+12),DE°³³°°		LD	(REG+14),HL°³³±°		LD	(REG+16),IX°³³²°		LD	(REG+18),IY°³³³°		LD	(REG+20),SP°³³´°		EXX			;PUT REGS BACK TO NORM°³³µ°		RET			;BACK TO BUSINESS°³³¶°	;	RESTORES ALL REGISTERS°³³·°	RSTORE	LD	IY,(REG+18)°³³¸°		LD	IX,(REG+16)°³³¹°		LD	HL,(REG+14)	;THESE ARE PRIME°³´°°		LD	DE,(REG+12)°³´±°		LD	BC,(REG+10)°³´²°		EXX			;SWAP EM°³´³°		LD	BC,(REG+8)°³´´°		PUSH	BC°³´µ°		POP	AF°³´¶°		EX	AF,AF'°³´·°		LD	HL,(REG+6)	;REGULAR REGS NOW°³´¸°		LD	DE,(REG+4)°³´¹°		LD	BC,(REG)°³µ°°		PUSH	BC		;LD AF WITH IT°³µ±°		POP	AF°³µ²°		LD	BC,(REG+2)	;GET BC°³µ³°		RET			;BACK TO THE RAT RACE°³µ´°	;°³µµ°	;	Puts random number in bc	0-65535°³µ¶°	;°³µ·°	;	All registers destroyed°³µ¸°	RND	LD	HL,(SEED)	;get seed°³µ¹°		ADD	HL,HL		;SLA HL°³¶°°		LD	(SEED),HL	;SAVE HL°³¶±°		JP	C,RETRAN°³¶²°		LD	A,(SEED+1)°³¶³°		LD	B,87H°³¶´°		XOR	B°³¶µ°		LD	(SEED+1),A°³¶¶°		LD	A,(SEED)°³¶·°		LD	B,0DH°³¶¸°		XOR	B°³¶¹°		LD	(SEED),A°³·°°	RETRAN	LD	BC,(SEED)°³·±°		RET				;DONE°³·²°	;°³·³°	;	RNDINT°³·´°	;	seeds the random routine°³·µ°	;	by using the clock°³·¶°	;°³··°	RNDINT	LD	A,(4217H)°³·¸°		LD	B,A°³·¹°		LD	A,(4118H)°³¸°°		XOR	B°³¸±°		LD	B,A°³¸²°		LD	A,(4119H)°³¸³°		XOR	B°³¸´°		LD	(SEED),A°³¸µ°		OR	B°³¸¶°		LD	(SEED+1),A°³¸·°		RET			;Done...°³¸¸°	;°³¸¹°	;	CHECKS FOR BREAK/CLEAR AND RETS TO TOS IF TRUE°³¹°°	BRKCLR	PUSH	AF			;SAVE AF°³¹±°		LD	A,(3840H)		;KB ADDR°³¹²°		CP	6			;BIT 1 AND 2°³¹³°		JR	Z,STOP°³¹´°		POP	AF			;RESTORE AF°³¹µ°		RET				;GO BACK°³¹¶°	STOP	POP	AF			;EMPTY STACK°³¹·°		POP	HL			;GET RET°³¹¸°		JP	RENTER			;BACK TO TOS°³¹¹°	;°´°°°	;	ENTRY: (A) 8 BIT VALUE TO BE CONVERTED°´°±°	;	EXIT : (HL) TO ASCII BYTES VALUES, HIGH AND LOW°´°²°	;	       (A), (C) = DESTROYED.°´°³°	;°´°´°	BIHEX	LD	C,A		;SAVE THE 2 DIGITS°´°µ°		SRL	A		;ALIGN THE HIGH DIG°´°¶°		SRL	A°´°·°		SRL	A°´°¸°		SRL	A°´°¹°		CALL	BITOHX		;CONVERT DIGIT TO ASCII°´±°°		LD	H,A		;SAVE THIS FOR RETURN°´±±°		LD	A,C		;RESTORE ORIGINAL°´±²°		AND	0FH		;JUST THE LOWER NIBBLE°´±³°		CALL	BITOHX		;CONVERT DIGIT TO ASCII°´±´°		LD	L,A		;SAVE THIS FOR RETURN°´±µ°		RET			;DONE°´±¶°	BITOHX	ADD	A,30H		;CONVERSION FACTOR°´±·°		CP	3AH		;IS IT 0-9°´±¸°		JP	M,H09		;IF SO THEN GO°´±¹°	;				COMMENT POETRY°´²°°		ADD	A,7		;ADJUST FOR A-F°´²±°	H09	RET			;RETURN°´²²°	;	ASCII HEX TO BINARY 4 BYTES TO 1 WORD°´²³°	;	ENTRY	:	(HL)=LEFTMOST DIGIT°´²´°	;	EXIT	:	BC  =BINARY NUMBER UNSIGNED°´²µ°	;		(HL), (BC), (A) = DESTROYED°´²¶°	;°´²·°	;°´²¸°	ASCH2B	LD	A,(HL)		;GET LEFTMOST DIGIT°´²¹°		CALL	HXTOBI		;CHANGE THE DIGIT°´³°°		JP	C,DIGERR°´³±°		SLA	A		;ALIGN THE HIGH DIGIT°´³²°		SLA	A°´³³°		SLA	A°´³´°		SLA	A°´³µ°		LD	B,A		;STORE IT°´³¶°		INC	HL		;TALLY 1 UP°´³·°		LD	A,(HL)		;GET NEXT DIGIT°´³¸°		CALL	HXTOBI		;CHANGE IT°´³¹°		JP	C,DIGERR°´´°°		OR	B		;ADD IN HIGH DIG°´´±°		LD	B,A		;SAVE RESULTS AGAIN°´´²°		INC	HL		;TALLY 2 UP°´´³°	ALTENT	EQU	$		;ALT ENTRY FOR 2 BYTES°´´´°		LD	A,(HL)		;GET NEXT DIGIT°´´µ°		CALL	HXTOBI		;CHANGE IT°´´¶°		JP	C,DIGERR°´´·°		SLA	A		;ALIGN THE HIGH DIGIT°´´¸°		SLA	A°´´¹°		SLA	A°´µ°°		SLA	A°´µ±°		LD	C,A		;STORE IT°´µ²°		INC	HL		;TALLY 3 UP°´µ³°		LD	A,(HL)		;GET NEXT DIGIT°´µ´°		CALL	HXTOBI		;CHANGE IT°´µµ°		JP	C,DIGERR°´µ¶°	°´µ·°		OR	C		;ADD IN HIGH DIGIT°´µ¸°		LD	C,A		;STORE RESULTS IN C°´µ¹°		RET			;BACK TO WHERE WE WERE°´¶°°	HXTOBI	SUB	30H		;TST 4 VLD°´¶±°		CP	0°´¶²°		JP	M,INVLD°´¶³°		CP	0AH°´¶´°		JP	P,AFTER°´¶µ°		JR	CCONT°´¶¶°	AFTER	CP	11H°´¶·°		JP	M,INVLD°´¶¸°		CP	17H°´¶¹°		JP	P,INVLD°´·°°	CCONT	CP	0AH		;CMP TO 10.CCP	0AH°´·±°		JP	M,LX2		;IF ITS =<9 LEAVE IT°´·²°		SUB	07H		;OTHERWIZE SUB 7 (A-F)°´·³°	LX2	SCF°´·´°		CCF°´·µ°		RET°´·¶°	INVLD	SCF			;ST ERR COD°´··°		RET°´·¸°	;	SUBROUTINE TO TURN OFF ALL NMI'S°´·¹°	;	NO REGISTERS ARE ALTERED.°´¸°°	;°´¸±°	ALLOFF	PUSH	AF		;SAVE AF TO STACK°´¸²°		LD	A,0		;ALL OFF°´¸³°		OUT	(0E0H),A	;TURN THEM OFF°´¸´°		POP	AF		;GET AF BACK°´¸µ°		RET			;BACK TO PROGRAM°´¸¶°	;	SUBROUTINE FOR TABLE SEARCH°´¸·°	;	ENTRY	:	(A) =KEY°´¸¸°	;			(HL)=START OF TABLE°´¸¹°	;			(DE)=LENGTH OF ENTRY IN BYTES°´¹°°	;			(C) =# OF ENTRIES IN TABLE°´¹±°	;	EXIT	:	Z FLAG SET IF FOUND ELSE RESET°´¹²°	;			(HL)=ADDR OF MATCH IF FOUND°´¹³°	;			(BC)=CURRENT # LEFT°´¹´°	;			(DE)=UNCHANGED°´¹µ°	;°´¹¶°	SEARCH	LD	B,0	;BC NOW HAS #°´¹·°	A1	CPI			;COMPARE A WITH (HL)°´¹¸°		JR	Z,FOUND		;GOT IT MA!°´¹¹°		JP	PO,NFND		;AT END AND NOT FOUND°µ°°°		ADD	HL,DE		;CURRENT+LENGTH+1°µ°±°		DEC	HL		;CURRENT+LENGTH°µ°²°		JR	A1		;TRY AGAIN°µ°³°	FOUND	DEC	HL		;ADJUST TO PROPER ADDR°µ°´°	NFND	RET			;GO BACK°µ°µ°	;	JUMPING ROUTINE°µ°¶°	;	J COMMAND°µ°·°	JUMP	LD	HL,(WKSPCE)	;SKIP J AND SPACE°µ°¸°		CALL	ASCH2B		;ASCII HEX TO BINARY°µ°¹°		LD	H,B		;LD HL,BC EQV°µ±°°		LD	L,C°µ±±°		PUSH	HL		;LOAD (SP) WITH JMP ADDR°µ±²°		CALL	RSTORE		;LOAD REGISTERS°µ±³°		RET			;FOOL IT INTO A JP°µ±´°	;°µ±µ°	;°µ±¶°	;	CALLING ROUTINE°µ±·°	;	C COMMAND°µ±¸°	CALL	LD	HL,(WKSPCE)	;SKIP C AND SPACE°µ±¹°		CALL	ASCH2B		;CHANGE TO BINARY°µ²°°		LD	(CALADR),BC°µ²±°		CALL	RSTORE		;LOAD REGISTERS°µ²²°		DEFB	0CDH		;CALL°µ²³°	CALADR	DEFW	00		;ALTERED INSTRUCTION°µ²´°		CALL	SAVE		;SAVE REGISTERS IN MEM°µ²µ°		LD	DE,4		;ADD CMD LEN TO PNTR°µ²¶°		LD	HL,(WKSPCE)	;GET OLD HL°µ²·°		ADD	HL,DE		;HL+DE TO HL°µ²¸°		LD	(WKSPCE),HL	;STORE THE RESULT°µ²¹°		JP	INTRPT		;BACK TO TOS°µ³°°	;	MODIFY MEMORY COMMAND°µ³±°	;	FORMAT:  M nnnn nn°µ³²°	;°µ³³°	MODIFY	LD	HL,(WKSPCE)	;SKIP M AND SPACE°µ³´°		CALL	ASCH2B		;CONVERT TO BINARY°µ³µ°		LD	HL,(ENDADD)	;COMPUTE°µ³¶°		LD	DE,(STADDR)	;LENGHT°µ³·°		XOR	A°µ³¸°		SBC	HL,DE°µ³¹°		LD	(PROLEN),HL	;STORE IT°µ´°°		LD	D,B		;LD DE,BC°µ´±°		LD	E,C		;MOCK UP°µ´²°		LD	HL,(WKSPCE)	;GET BUF POINTER°µ´³°		PUSH	DE		;SAVE DE°µ´´°		LD	DE,4		;SKIP FIRST ADDR°µ´µ°		ADD	HL,DE		;HL+DE TO HL°µ´¶°		POP	DE		;GET DE BACK°µ´·°		CALL	ALTENT		;ONLY TWO BYTES THIS TIME°µ´¸°		LD	A,C		;GET BINARY VALUE°µ´¹°		EX	DE,HL		;SWAP THESE TWO°µµ°°		LD	(HL),A		;LOAD MEMORY°µµ±°		LD	DE,6		;ADD CMD LEN TO PNTR°µµ²°		LD	HL,(WKSPCE)	;GET OLD HL°µµ³°		ADD	HL,DE		;CALC NEW HL°µµ´°		LD	(WKSPCE),HL	;STORE THE RESULT°µµµ°		JP	INTRPT		;GO BACK TO TOS°µµ¶°	;	SUBROUTINE TO PRINT CONTENTS OF MEMORY°µµ·°	;	FORMAT: P nnnn°µµ¸°	;°µµ¹°	DSPMEM	LD	HL,(WKSPCE)	;SKIP P AND SPACE°µ¶°°		CALL	ASCH2B		;CONVERT TO BINARY°µ¶±°		LD	A,(BC)		;GET THE CONTENTS OF MEM°µ¶²°		CALL	BIHEX		;CONVERT A TO ASCII HEX°µ¶³°		LD	A,H		;SWAP°µ¶´°		LD	H,L		;H AND°µ¶µ°		LD	L,A		;L°µ¶¶°		LD	(OUTBUF),HL	;STORE HEX TO OUTPUT BUF°µ¶·°		LD	A,0DH		;<CR>°µ¶¸°		LD	(OUTBUF+2),A	;TERMINATE NUMBER°µ¶¹°		LD	HL,OUTBUF	;PRINT THE OUTPUT BUFFER°µ·°°		CALL	VDLINE		;PRINT IT OUT°µ·±°		LD	DE,4		;CMD LENGTH°µ·²°		LD	HL,(WKSPCE)	;GET OLD HL°µ·³°		ADD	HL,DE		;HL < HL+DE°µ·´°		LD	(WKSPCE),HL	;STORE THE RESULT°µ·µ°		JP	INTRPT		;BACK TO TOS°µ·¶°	;°µ··°	;	I/O ROUTING SUBROUTINE°µ·¸°	;°µ·¹°	ROUT	LD	HL,(WKSPCE)	;FROM HERE°µ¸°°		LD	DE,4220H	;TO HERE°µ¸±°		LD	BC,4		;4 BYTES°µ¸²°		LDIR			;MOVE IT°µ¸³°		CALL	ROUTE		;$ROUTE I/O°µ¸´°		LD	HL,(WKSPCE)°µ¸µ°		LD	DE,4		;CMD LEN°µ¸¶°		ADD	HL,DE		;ADD IT TO POINTER°µ¸·°		LD	(WKSPCE),HL	;SAVE IT°µ¸¸°		JP	INTRPT		;BACK TO NEXT COMMAND°µ¸¹°	;°µ¹°°	;	INIT I/O SUBROUTINE°µ¹±°	;°µ¹²°	INITDR	CALL	0069H		;INITIO°µ¹³°		JP	INTRPT		;GOT NXT CMD°µ¹´°	;°µ¹µ°	;	HELP ROUTINE (THATS RIGHT HELP)°µ¹¶°	;°µ¹·°	HELP	LD	HL,HLPMSG	;POINT TO HELP°µ¹¸°		LD	B,14		;12 LINES°µ¹¹°	XJM19	CALL	VDLINE		;PRINT OUT MESSAGE°¶°°°		DJNZ	XJM19		;DONE°¶°±°		JP	RENTER		;BACK TO TOS°¶°²°	;°¶°³°	;	REGISTER PRINTING SUBROUTINE°¶°´°	;°¶°µ°	REGPNT	LD	HL,REGLBL	;PNT LBL°¶°¶°		CALL	VDLINE°¶°·°		LD	B,11		;22 BYTES°¶°¸°		LD	IX,REG		;BASE ADDR°¶°¹°	REGLOP	LD	A,(IX)		;GT BYTE°¶±°°		CALL	BIHEX		;CONVERT IT°¶±±°		LD	A,H°¶±²°		CALL	VDCHAR		;PRINT HEX DIG°¶±³°		LD	A,L°¶±´°		CALL	VDCHAR°¶±µ°		LD	A,(IX+1)	;NEXT DIG°¶±¶°		CALL	BIHEX°¶±·°		LD	A,H°¶±¸°		CALL	VDCHAR°¶±¹°		LD	A,L°¶²°°		CALL	VDCHAR°¶²±°		LD	A,20H		;A SPACE°¶²²°		CALL	VDCHAR		;PRINT IT°¶²³°		INC	IX		;NEXT REG°¶²´°		INC	IX		;TWO BYTES°¶²µ°		DJNZ	REGLOP		;CONTINUE?°¶²¶°		LD	A,0DH		;<CR>°¶²·°		CALL	VDCHAR		;PRINT IT°¶²¸°		JP	INTRPT		;GET NEXT CMD°¶²¹°	;°¶³°°	;	TAPE LOADING SUBROUTINE°¶³±°	;	LOADS SYSTEM FORMAT TAPE°¶³²°	;°¶³³°	TLOAD	DI			;NO (INT)ERUPTIONS°¶³´°		LD	HL,BRKTAP	;SET UP CASSETTE°¶³µ°		LD	(4204H),HL	;BREAK XFER VECTOR°¶³¶°		XOR	A		;0 ACC°¶³·°		CALL	CSHIN		;GET LEADER°¶³¸°		CALL	CSIN		;GET 1'ST BT°¶³¹°		CP	'U'°¶´°°		JP	NZ,WRNGTP	;NOT A SYSTEM TAPE°¶´±°		LD	HL,3C00H+30H	;END OF 1 LN°¶´²°		LD	B,6		;6 BYTES°¶´³°	GTNAME	CALL	CSIN		;GET AND°¶´´°		LD	(HL),A		;DISPLAY°¶´µ°		INC	HL		;THE°¶´¶°		DJNZ	GTNAME		;FILENAME°¶´·°	;	THIS PART GETS ST ADDR°¶´¸°	GSTADD	CALL	CSIN°¶´¹°		CP	3CH		;"<"°¶µ°°		JR	NZ,GSTADD°¶µ±°		CALL	CSIN°¶µ²°		LD	B,A		;BYTE COUNT°¶µ³°		CALL 	CSIN°¶µ´°		LD	L,A°¶µµ°		LD	C,A		;FIRST CHCKSM°¶µ¶°		CALL	CSIN°¶µ·°		LD	H,A°¶µ¸°		ADD	A,C°¶µ¹°		LD	C,A°¶¶°°		LD	(STADDR),HL°¶¶±°		JR	ENTLOP°¶¶²°	STLOAD	CALL	CSIN°¶¶³°		CP	78H		;"x" CHECK FOR XFER ADDR°¶¶´°		JR	Z,FINISH	;IF SO THEN GO FINISH UP°¶¶µ°		CP	3CH		;CHECK FOR CONT "<"°¶¶¶°		JR	NZ,STLOAD	;GET ANOTHER BYTE IF NOT°¶¶·°		CALL	CSIN°¶¶¸°		LD	B,A		;NUM OF BYTES°¶¶¹°		CALL	CSIN°¶·°°		LD	L,A		;LSB OF ST ADDR°¶·±°		LD	C,A		;BEG OF CHCKSUM°¶·²°		CALL	CSIN°¶·³°		LD	H,A		;MSB OF ST ADDR°¶·´°		ADD	A,C		;COMPUTE PART CHCKSUM°¶·µ°		LD	C,A		;STORE NEW CHCKSUM°¶·¶°	ENTLOP	XOR	A°¶··°	LDLOOP	CALL	CSIN		;GT BT°¶·¸°		LD	(HL),A		;STORE IT°¶·¹°		INC	HL		;NEXT°¶¸°°		ADD	A,C		;CMPUT CHCKSUM°¶¸±°		LD	C,A		;SAVE IT°¶¸²°		DJNZ	LDLOOP°¶¸³°		LD	(ENDADD),HL°¶¸´°		CALL	CSIN		;GET CHECKSUM°¶¸µ°		CP	C		;CP IT WITH CMPUTED SUM°¶¸¶°		JR	NZ,CHKERR	;WE GOT AN ERROR°¶¸·°		JR	STLOAD		;GET THE NEXT BLOCK°¶¸¸°	FINISH	CALL	CSIN°¶¸¹°		LD	L,A		;GET°¶¹°°		CALL	CSIN°¶¹±°		LD	H,A		;TRANSFER ADDR°¶¹²°		EI°¶¹³°		LD	(ENTADD),HL°¶¹´°		CALL	CSOFF		;CASS OFF°¶¹µ°		LD	A,(STADDR+1)°¶¹¶°		CALL	BIHEX°¶¹·°		EX	DE,HL		;SWAP°¶¹¸°		LD	H,E		;THE°¶¹¹°		LD	L,D		;REGISTERS°·°°°		LD	(CAS1),HL°·°±°		LD	A,(STADDR)°·°²°		CALL	BIHEX°·°³°		EX	DE,HL		;SWP°·°´°		LD	H,E°·°µ°		LD	L,D		;REG°·°¶°		LD	(CAS1+2),HL°·°·°		LD	A,(ENDADD+1)°·°¸°		CALL	BIHEX°·°¹°		EX	DE,HL°·±°°		LD	H,E°·±±°		LD	L,D°·±²°		LD	(CAS2),HL°·±³°		LD	A,(ENDADD)°·±´°		CALL	BIHEX°·±µ°		EX	DE,HL°·±¶°		LD	H,E°·±·°		LD	L,D°·±¸°		LD	(CAS2+2),HL°·±¹°		LD	A,(ENTADD+1)°·²°°		CALL	BIHEX°·²±°		EX	DE,HL°·²²°		LD	H,E°·²³°		LD	L,D°·²´°		LD	(CAS3),HL°·²µ°		LD	A,(ENTADD)°·²¶°		CALL	BIHEX°·²·°		EX	DE,HL		;SWP°·²¸°		LD	H,E°·²¹°		LD	L,D		;REGS°·³°°		LD	(CAS3+2),HL°·³±°		LD	HL,CASMS2°·³²°		CALL	VDLINE		;DISPLAY TAPE PARAMETERS°·³³°		JP	INTRPT°·³´°	CHKERR	CALL	CSOFF°·³µ°		LD	HL,CASMS1°·³¶°		CALL	VDLINE°·³·°		EI°·³¸°		JP	RENTER°·³¹°	WRNGTP	CALL	CSOFF		;CAS OFF°·´°°		EI°·´±°		LD	HL,CASMS5	;POINT TO MES°·´²°		CALL	VDLINE°·´³°		JP	RENTER°·´´°	BRKTAP	CALL	CSOFF°·´µ°		POP	HL		;RET RET ADDR OFF STACK°·´¶°		JP	RENTER°·´·°	;°·´¸°	°·´¹°	;	TAPE WRITING SUBROUTINE°·µ°°	;°·µ±°	TWRITE	LD	HL,(WKSPCE)	;POINT TO DIGITS°·µ²°		CALL	ASCH2B		;CONVERT TO BINARY°·µ³°		LD	(STADDR),BC	;STORE ST ADDR°·µ´°		INC	HL		;POINT TO NEXT ADDR°·µµ°		CALL	ASCH2B		;CVT IT°·µ¶°		LD	(ENDADD),BC°·µ·°		INC	HL		;°·µ¸°		CALL	ASCH2B°·µ¹°		LD	(ENTADD),BC°·¶°°		PUSH	HL		;SAVE HL°·¶±°		LD	HL,(ENDADD)°·¶²°		LD	DE,(STADDR)	;COMPUTE°·¶³°		SBC	HL,DE°·¶´°		LD	(PROLEN),HL	;PRG LEN°·¶µ°		LD	HL,OUTBUF°·¶¶°		LD	DE,OUTBUF+1°·¶·°		LD 	BC,5		;BLANK OUT NAM°·¶¸°		LD	(HL),20H°·¶¹°		LDIR°··°°		POP	HL		;RST HL°··±°	STNAME	LD	DE,OUTBUF°··²°	NAMLOP	INC	HL°··³°		LD	A,(HL)°··´°		CP	'/'°··µ°		JR	Z,NAMEDN°··¶°		CP	0DH		;<CR>°···°		JR	NZ,TLCONT	;TAPE LOAD CONTINUE°··¸°		DEC	HL		;<CR>-1°··¹°		JP	NAMEDN°·¸°°	TLCONT	LD	(DE),A°·¸±°		INC	DE°·¸²°		JR	NAMLOP°·¸³°	NAMEDN	INC	HL°·¸´°		LD	(WKSPCE),HL	;SAVE NEW POINTER°·¸µ°		LD	HL,BRKTAP	;SET <BREAK> VECTOR°·¸¶°		LD	(4204H),HL°·¸·°		DI°·¸¸°		XOR	A°·¸¹°		CALL	CSHWR		;WRITE HEADER°·¹°°		LD	A,'U'°·¹±°		CALL	CSOUT		;WRITE BYTE°·¹²°		LD	B,6		;WRT°·¹³°		LD	HL,OUTBUF	;POINT TO NAME°·¹´°	WRTNAM	LD	A,(HL)°·¹µ°		CALL	CSOUT°·¹¶°		INC	HL°·¹·°		DJNZ	WRTNAM°·¹¸°		LD	HL,(PROLEN)°·¹¹°		LD	DE,256°¸°°°		LD	B,0°¸°±°		XOR	A		;CLEAR FLAGS°¸°²°	NUMBLK	INC	B°¸°³°		SBC	HL,DE°¸°´°		JR	NC,NUMBLK°¸°µ°	WRLOOP	PUSH	BC		;SAVE BLK CNT°¸°¶°		LD	A,'<'°¸°·°		CALL	CSOUT°¸°¸°		XOR	A		;ZERO A AND°¸°¹°		CALL	CSOUT		;256 BYTES°¸±°°		LD	C,0°¸±±°		LD	HL,(STADDR)°¸±²°		LD	A,L		;WRITE ST ADDR°¸±³°		CALL	CHEKSM°¸±´°		LD	A,H°¸±µ°		CALL	CHEKSM°¸±¶°		LD	B,0°¸±·°	WRBLCK	LD	A,(HL)°¸±¸°		CALL	CHEKSM°¸±¹°		INC	HL°¸²°°		DJNZ	WRBLCK°¸²±°		LD	A,C		;WRITE°¸²²°		CALL	CSOUT		;CHECKSUM°¸²³°		LD	(STADDR),HL°¸²´°		POP	BC		;GET BACK BLOCK COUNT°¸²µ°		LD	A,(3840H)	;KEYBOARD VECTOR°¸²¶°		CP	4		;BREAK???°¸²·°		JR	Z,TABORT	;IF SO THEN GO°¸²¸°		DJNZ	WRLOOP°¸²¹°		LD	A,'x'		;WRITE°¸³°°		CALL	CSOUT°¸³±°		LD	HL,(ENTADD)°¸³²°		LD	A,L		;ENTRY°¸³³°		CALL	CSOUT°¸³´°		LD	A,H°¸³µ°		CALL	CSOUT		;ADDRESS°¸³¶°		CALL	CSOFF		;CASSETTE OFF°¸³·°		EI°¸³¸°		JP	INTRPT°¸³¹°	TABORT	CALL	CSOFF		;TURN CASS OFF°¸´°°		LD	HL,CASABO	;TAPE ABORT TEXT°¸´±°		CALL	VDLINE°¸´²°		EI°¸´³°		JP	INTRPT		;BACK FOR SOME MORE°¸´´°	CHEKSM	PUSH	AF		;SAVE A°¸´µ°		ADD	A,C		;CMPT CHCKSUM°¸´¶°		LD	C,A		;STR IT°¸´·°		POP	AF		;GET AF BACK°¸´¸°		JP	CSOUT		;WRITE ACCUM°¸´¹°	;°¸µ°°	;	Routine to go back to debug°¸µ±°	;	will work on both tape and disk system.°¸µ²°	;°¸µ³°	DEBUG	RST	30H		;Thats all°¸µ´°	;°¸µµ°	;°¸µ¶°	;	Execute TRSDOS command°¸µ·°	;°¸µ¸°	TRSDOS	LD	HL,402DH	;Save°¸µ¹°		LD	DE,TMPVAR	;Three°¸¶°°		LD	BC,03		;Trsdos instructions°¸¶±°		LDIR			;Save them°¸¶²°		LD	A,0C3H		;JP°¸¶³°		LD	(402DH),A	;Save jump°¸¶´°		LD	HL,TRSADD°¸¶µ°		LD	(402EH),HL	;Save jump addr°¸¶¶°	;°¸¶·°	;	Save first 3 bytes of TRSDOS error routine°¸¶¸°	;°¸¶¹°		LD	HL,4409H	;Error routine addr°¸·°°		LD	DE,TMPVR1°¸·±°		LD	BC,3°¸·²°		LDIR			;Save them°¸·³°		LD	A,0C3H		;JP°¸·´°		LD	(4409H),A	;Save JP°¸·µ°		LD	HL,TRSERR	;Set new°¸·¶°		LD	(440AH),HL	;Error address°¸··°		LD	HL,(WKSPCE)	;Skip '&'°¸·¸°		JP	COMDOS		;Execute it.°¸·¹°	TRSADD	LD	HL,TMPVAR	;Restore°¸¸°°		LD	DE,402DH	;First 3 instructions°¸¸±°		LD	BC,03H		;of TRSDOS Ready°¸¸²°		LDIR			;Restore them°¸¸³°		LD	HL,TMPVR1°¸¸´°		LD	DE,4409H	;Trsdos error routine°¸¸µ°		LD	BC,03H°¸¸¶°		LDIR			;Move it back°¸¸·°		LD	A,00H°¸¸¸°		LD	(16916),A	;Zero scroll protect°¸¸¹°		JP	RENTER		;TEST line.°¸¹°°	TRSERR	LD	HL,TMPVR1°¸¹±°		LD	DE,4409H	;TRSDOS error routine°¸¹²°		LD	BC,3		;First 3 bytes°¸¹³°		LDIR			;Restore them°¸¹´°		SET	7,A		;Return to us°¸¹µ°		SET	6,A		;Give message°¸¹¶°		CALL	ERRDSP		;Display message°¸¹·°		POP	HL		;Offset SP we were called°¸¹¸°		JP	TRSADD		;Go back°¸¹¹°	;°¹°°°	;°¹°±°	;	INSTR  FINDS A KEY STRING IN A SRCH STRNG°¹°²°	;	ENTRY	(HL)	POINTS TO SEARCH STRING°¹°³°	;		(DE)	POINTS TO KEY STRING°¹°´°	;		 BC	NUM OF BYTES IN SEARCH STRING°¹°µ°	;	EXIT	IF  ZERO STATIS (HL) POINTS TO START°¹°¶°	;	OF KEY STRING°¹°·°	INSTR	LD	A,(DE)		;1ST CHAR°¹°¸°		CPIR°¹°¹°		RET	NZ		;BACK IF NOT FOUND°¹±°°		PUSH	AF°¹±±°		PUSH	HL°¹±²°		PUSH	DE		;SV PNTRS°¹±³°		DEC	HL°¹±´°		CALL	BLCKCP		;CP THEM°¹±µ°		POP	DE°¹±¶°		POP	HL°¹±·°		JR	Z,CCCONT°¹±¸°		POP	AF°¹±¹°		RET	PO		;BC=0°¹²°°		JR	INSTR		;HAVE TO LOAD DE NOW°¹²±°	CCCONT	POP	HL°¹²²°		RET°¹²³°	;°¹²´°	;	BLOCK COMPARE COMPARES TWO BLOCKS°¹²µ°	;	ENTRY	(HL),(DE) POINT TO STRINGS ENDED BY 03H°¹²¶°	;	EXIT	ZERO STATIS MEANS EQUAL°¹²·°	;	NOTE ONLY COMPARES TO LENGTH OF (DE)°¹²¸°	;	EX: (DE)="ABCD" (HL)="ABCDEF" WOULD BE EQUAL°¹²¹°	BLCKCP	LD	A,(DE)°¹³°°		CP	03		;<ETX>°¹³±°		RET	Z°¹³²°		CP	(HL)°¹³³°		RET	NZ°¹³´°		INC	HL°¹³µ°		INC	DE°¹³¶°		JR	BLCKCP°¹³·°	;°¹³¸°	;	CRUNCH TAKES SPACES OUT OF TEXT°¹³¹°	;°¹´°°	;	ENTRY:	HL=DE=BEGINNING OF TEXT°¹´±°	;°¹´²°	CRUNCH	LD	A,(HL)		;GET A BYTE°¹´³°		CP	20H		;SPACE ?°¹´´°		JR	NZ,NOSPCE°¹´µ°		INC	HL		;SKIP THIS BYTE°¹´¶°		JR	CRUNCH		;GO TEST NEXT BYTE°¹´·°	NOSPCE	LDI			;TRANSFER ONLY NON SPACE°¹´¸°		CP	03		;<ETX>?°¹´¹°		RET	Z		;BACK IF SO°¹µ°°		JR	CRUNCH		;ELSE CONTINUE°¹µ±°	;°¹µ²°	;	RSCROLL SCROLLS TO THE RIGHT°¹µ³°	;°¹µ´°	RSCROL	LD	HL,3C00H+3FEH	;LAST SCN POS-1°¹µµ°		LD	DE,3C00H+3FFH	;LAST SCN POS°¹µ¶°		LD	BC,3FFH		;1K-1 BYTES°¹µ·°		LDDR			;MOVE IT°¹µ¸°		LD	B,16		;16 LINES°¹µ¹°		LD	DE,40H		;64 CHARS PER LINE°¹¶°°		LD	A,20H		;SPACE°¹¶±°		LD	HL,3C00H	;START HERE°¹¶²°	COLCLR	LD	(HL),A		;CLEAR SCREEN POS°¹¶³°		ADD	HL,DE		;COMPUTE NEXT LINE°¹¶´°		DJNZ	COLCLR		;GO IF NOT DONE°¹¶µ°		RET			;BACK TO BUSINESS°¹¶¶°	;°¹¶·°	;	FORWARD SCROLLING°¹¶¸°	;°¹¶¹°	USCROL	LD	HL,3C00H+40H	;BEG OF 2ND LINE°¹·°°		LD	DE,3C00H	;TO HERE°¹·±°		LD	BC,1024-64	;THIS MANY BYTES°¹·²°		LDIR			;MOVE IT°¹·³°		LD	HL,3FBFH	;BEG OF LAST LINE°¹·´°		LD	DE,3FC0H	;2ND POS LST LINE°¹·µ°		LD	BC,3FH°¹·¶°		LD	(HL),20H	;STORE SPACE°¹··°		LDIR			;REPEAT IT TO BLANK LINE°¹·¸°		RET			;BACK TO BUSINESS°¹·¹°	;°¹¸°°	;	REVERSE SCROLLING°¹¸±°	;°¹¸²°	DSCROL	LD	HL,3FFFH-127	;FROM 2ND LST LN°¹¸³°		LD	DE,3FFFH-63	;TO LST LN°¹¸´°		LD	BC,400H-40H	;1K-1LINE°¹¸µ°		LDDR			;MOVE IT°¹¸¶°		LD	HL,3C00H	;ZERO FST LINE°¹¸·°		LD	(HL),20H	;BLANK°¹¸¸°		LD	DE,3C01H	;TO HERE°¹¸¹°		LD	BC,3FH		;1 LINE°¹¹°°		LDIR°¹¹±°		RET			;DONE!°¹¹²°	;°¹¹³°	;	LEFT SCROLLING°¹¹´°	;°¹¹µ°	LSCROL	LD	HL,3C00H+1°¹¹¶°		LD	DE,3C00H°¹¹·°		LD	BC,3FFH		;THIS MANY BYTES°¹¹¸°		LDIR			;MOVE IT°¹¹¹°		LD	B,16±°°°°		LD	DE,40H		;1 LINE DISPLACEMENT±°°±°		LD	HL,3C00H+3FH	;END OF 1ST LINE±°°²°		LD	A,20H		;SPC±°°³°	C64CLR	LD	(HL),A		;BLANK MEMORY±°°´°		ADD	HL,DE		;COMPUTE NEXT MEM LOC±°°µ°		DJNZ	C64CLR		;GO IF NOT DONE±°°¶°		RET			;DONE±°°·°	;±°°¸°	;	SCREEN INVERSION INVERTS GRAPHICS±°°¹°	;±°±°°	INVSCN	LD	HL,3C00H	;BEG OF SCN±°±±°		LD	BC,400H		;1024 BYTES±°±²°	INVLOP	LD	A,(HL)		;GET BYTE±°±³°		AND	192		;LAST 2 BITS ONLY±°±´°		CP 	128		;BIT 7 AND NOT 6±°±µ°		JR	NZ,NOINV	;IF NOT DONT INVERT±°±¶°		LD	A,(HL)		;GET BYTE AGAIN±°±·°		CPL			;INVERT BITS±°±¸°		SET	7,A		;BIT 7 ON±°±¹°		RES	6,A		;6 OFF±°²°°		LD	(HL),A		;SAVE IT±°²±°	NOINV	INC	HL±°²²°		DEC	BC		;CHECK±°²³°		LD	A,B		;BC±°²´°		OR	C		;FOR 0±°²µ°		JR	NZ,INVLOP±°²¶°		RET			;BACK±°²·°	;±°²¸°	;	CVTUPC CONVERTS TEXT TO UPPER CASE±°²¹°	;	ENTRY:	(HL) POINTS TO TEXT±°³°°	;±°³±°	CVTUPC	LD	A,(HL)		;GET BYTE±°³²°		CP	03H		;DONE?±°³³°		RET	Z		;RETURN IF SO±°³´°		CP	97		;LESS THAN "a"±°³µ°		JP	M,NOCVT±°³¶°		CP	122		;MORE THAN "z"±°³·°		JP	P,NOCVT±°³¸°		AND	0DFH		;MAKE CONVERSION±°³¹°		LD	(HL),A		;STORE IT±°´°°	NOCVT	INC	HL		;NEXT BYTE±°´±°		JR	CVTUPC±°´²°	;±°´³°	;	SCREEN SAVE (SAVES SCREEN TO MEMORY)±°´´°	;	ENTRY:	DE POINTS TO MEM LOC TO START STORING AT±°´µ°	;±°´¶°	SAVSCN	LD	HL,3C00H	;BEG OF SCN±°´·°		LD	BC,400H		;1K±°´¸°		LDIR			;MOVE IT±°´¹°		RET			;BACK±°µ°°	;±°µ±°	;	SCREEN RESTORE ROUTINE ±°µ²°	;	RESTORES SCREEN FROM MEMORY±°µ³°	;	ENTRY:	HL POINT TO MEM LOC TO GET SCREEN FROM±°µ´°	;±°µµ°	RSTSCN	LD	DE,3C00H	;BEG OF SCN±°µ¶°		LD	BC,400H		;1K±°µ·°		LDIR			;MOVE IT±°µ¸°		RET±°µ¹°	;	DIGIT ERR SUB±°¶°°	DIGERR	LD	HL,ERRTXT±°¶±°		CALL	VDLINE±°¶²°		POP	HL±°¶³°		JP	RENTER±°¶´°	;±°¶µ°	;	WORKING STORAGE±°¶¶°	;±°¶·°	REG	DEFS	24		;SPACE FOR REGS±°¶¸°	STADDR	DEFW	00±°¶¹°	SEED	DEFW	0FFFFH		;Rnd # seed±°·°°	ENDADD	DEFW	00±°·±°	ENTADD	DEFW	00±°·²°	WKSPCE	DEFS	2		;SPACE FOR REGISTERS±°·³°	PROLEN	DEFW	00±°·´°	INPBUF	DEFS	256		;INPUT BUFFER±°·µ°	OUTBUF	DEFS	256		;OUTPUT BUFFER±°·¶°	TMPVAR	DEFS	4±°··°	TMPVR1	DEFS	4±°·¸°		END	TINIT		;END AT STARTING ADDRESS