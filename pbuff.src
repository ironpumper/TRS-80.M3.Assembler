°°°°±	;°°°±±	;°°°²±	;	Program	:	PBUFF/SRC°°°³±	;	Author	:	John C. Orlowski°°°´±	;	Date	:	02-Feb-85°°°µ±	;	System	:	TRS-80 Mod III 48K 2disk RS232°°°¶±	;°°°·±	;°°°¸±	PRSTAT	EQU	0F8H		;Pr statis port°°°¹±	MEMEND	EQU	4411H		;End of memory°°±°±		ORG	0DF00H°°±±±	BUFFER	DEFS	8192°°±²±	BLIMIT	EQU	$-1°°±³±	NUMLFT	DEFW	8192°°±´±	TOTSZE	DEFW	8192°°±µ±	BEGBUF	DEFW	BUFFER°°±¶±	INPPNT	DEFW	BUFFER°°±·±	OUTPNT	DEFW	BUFFER°°±¸±	;°°±¹±	START	LD	HL,PRCHR	;New print char addr°°²°±		LD	(4026H),HL	;Save it to vect°°²±±		LD	HL,ISR		;Interupt service rout°°²²±		LD	(4013H),HL	;Save it°°²³±		LD	HL,BUFFER	;Beginning of buffer°°²´±		DEC	HL		;-1°°²µ±		LD	(MEMEND),HL	;Trsdos End of mem°°²¶±		JP	402DH		;TRSDOS°°²·±	ISR	PUSH	AF°°²¸±		PUSH	DE°°²¹±		PUSH	HL°°³°±	ISRLP	IN	A,(PRSTAT)	;Get printer statis°°³±±		AND	128+64+32+16	;Mask off bits 0-3°°³²±		CP	32+16		;Not fault, select°°³³±		JP	NZ,ENDPNT	;If not ready then go°°³´±		LD	HL,(NUMLFT)	;Get number left°°³µ±		LD	DE,(TOTSZE)	;Get total size°°³¶±		OR	A		;CCF°°³·±		SBC	HL,DE		;Compare them°°³¸±		JP	Z,ENDPNT	;If none in buff then end°°³¹±		CALL	GETBUF		;Get char°°´°±		CALL	PRTCHR		;PRint it°°´±±		PUSH	BC		;Save BC°°´²±		LD	B,100D°°´³±	DLOOP	DJNZ	DLOOP°°´´±		POP	BC°°´µ±		JP	ISRLP		;Repeat until nt rdy°°´¶±	ENDPNT	POP	HL°°´·±		POP	DE°°´¸±		POP	AF°°´¹±		JP	3018H		;End interupt routine°°µ°±	;°°µ±±	;°°µ²±	PRCHR	DI°°µ³±		LD	A,C		;C=char to print°°µ´±		PUSH	AF°°µµ±		CALL	ROOM		;Room left°°µ¶±		JP	NZ,MRLEFT	;If so then go°°µ·±		PUSH	AF		;Save char°°µ¸±		CALL	GETBUF		;Get char°°µ¹±		CALL	PRTCHR		;Print it°°¶°±		POP	AF		;Get A back°°¶±±	MRLEFT	CP	0DH		;<CR>°°¶²±		JP	Z,CR°°¶³±		CALL	PUTBUF		;Put char in buff°°¶´±	PUTDN	POP	AF°°¶µ±		POP	HL		;Pop registers off stck°°¶¶±		POP	DE°°¶·±		POP	IX°°¶¸±		POP	HL		;First is to balance stck°°¶¹±		POP	BC°°·°±		EI°°·±±		RET			;Return°°·²±	;°°·³±	;	Routine to convert <CR> to <LF> <CR>°°·´±	;°°·µ±	CR	LD	A,0AH		;<LF>°°·¶±		CALL	PUTBUF		;Already Know ok to put°°··±		CALL	ROOM		;Room to put <CR>°°·¸±		JP	NZ,OK4CR	;If so then go°°·¹±		CALL	GETBUF		;Otherwise print°°¸°±		CALL	PRTCHR		;One character°°¸±±	OK4CR	LD	A,0DH		;<CR>°°¸²±		CALL	PUTBUF		;Put into buffer°°¸³±		JP	PUTDN°°¸´±	;°°¸µ±	;°°¸¶±	GETBUF	LD	HL,(OUTPNT)	;Get output pointer°°¸·±		LD	A,(HL)		;Get char°°¸¸±		INC	HL		;Increment HL°°¸¹±		LD	DE,BLIMIT	;Get upper limit°°¹°±		EX	DE,HL		;Don't destroy HL°°¹±±		OR	A		;CCF°°¹²±		SBC	HL,DE		;CMP HL,DE°°¹³±		JP	P,GETOK		;Ok no overlap°°¹´±		LD	DE,(BEGBUF)	;Point to beg of buff°°¹µ±	GETOK	LD	(OUTPNT),DE	;Save new pointer°°¹¶±		LD	HL,(NUMLFT)	;Number left in buff°°¹·±		INC	HL		;Increment it°°¹¸±		LD	(NUMLFT),HL	;Save this number°°¹¹±		RET			;Back to business°±°°±	;°±°±±	;°±°²±	PUTBUF	LD	HL,(INPPNT)	;Buff input pointer°±°³±		LD	(HL),A		;Save char°±°´±		INC	HL		;Increment pointer°±°µ±		LD	DE,BLIMIT	;Get upper limit°±°¶±		EX	DE,HL		;Save HL°±°·±		OR	A		;Clear flags°±°¸±		SBC	HL,DE		;CMP HL,DE°±°¹±		JP	P,PUTOK		;If ok then go°±±°±		LD	DE,(BEGBUF)	;Point to beg of buff°±±±±	PUTOK	LD	(INPPNT),DE	;Save new pointer°±±²±		LD	HL,(NUMLFT)	;Get number left°±±³±		DEC	HL		;Decrement it°±±´±		LD	(NUMLFT),HL	;Save it°±±µ±		RET			;Back to business°±±¶±	;°±±·±	;°±±¸±	ROOM	LD	D,A		;Save A°±±¹±		LD	HL,(NUMLFT)	;Get number left°±²°±		LD	A,H		;CP HL°±²±±		OR	L		;     ,0°±²²±		LD	A,D		;Get A back°±²³±		RET			;Back to business°±²´±	;°±²µ±	;°±²¶±	PRTCHR	PUSH	AF		;Save AF°±²·±	PRTLP	LD	A,(3840H)	;Keyboard vector°±²¸±		AND	6		;<Break> / <Clear>°±²¹±		CP	6		;Both keys?°±³°±		JP	Z,PABORT	;Abort°±³±±		IN	A,(0F8H)	;Get statis°±³²±		AND	128+64+32+16	;Mask out bits 0-3°±³³±		CP	48		;16+32°±³´±		JP	NZ,PRTLP	;If not ready then wait°±³µ±		POP	AF		;Get char°±³¶±		OUT	(0F8H),A	;Output char°±³·±		RET°±³¸±	PABORT	POP	AF		;Get AF back°±³¹±		RET°±´°±		END	START