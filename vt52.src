°°°±°	;°°°²°	;°°°³°	;	Program	:	VT52/SRC°°°´°	;	Author	:	John C. Orlowski°°°µ°	;	Date	:	Spring of 82..°°°¶°	;	System	:	TRS-80 Model III 48K 2drive RS232°°°·°	;°°°¸°	;	  Copyright (c) 1983 by John C. Orlowski°°°¹°	;--------------------------------------------------------°°±°°	;°°±±°	;°°±²°	;°°±³°	;°°±´°	;°°±µ°	;°°±¶°	;°°±·°	;°°±¸°	;		This program is a DEC VT52 emulator°°±¹°	;	program that will respect all the protocalls°°²°°	;	and functions of a DEC VT52 with the exception°°²±°	;	of only having a 64x16 screen as opposed to a°°²²°	;	80x24 screen.  The only other protocalls the°°²³°	;	program currently does not handle are °°²´°	;	ESC Z	- Identify terminal type (Very soon)°°²µ°	;	ESC (open bracket) - Hold screen mode (Maybe)°°²¶°	;	ESC (Backslash)    - Exit hold screen mode°°²·°	;	ESC =   - Enter alternate keypad mode (Never)°°²¸°	;	ESC >   - Exit alternate keypad mode°°²¹°	;	ESC F   - Enter graphics mode°°³°°	;	ESC G   - Exit graphics mode°°³±°	;°°³²°	;°°³³°	;	The program in addition to emulating the°°³´°	;	protocalls of a DEC VT52 also provides many°°³µ°	;	additional features comparable to full blown°°³¶°	;	communication programs.  One powerfull feature°°³·°	;	of the program is a <CLEAR> function table°°³¸°	;	this gives the user over a hundred <CLEAR>°°³¹°	;	and character combinations that he can define°°´°°	;	with his own machine language routine.°°´±°	;	some of these are pre-defined, however these can°°´²°	;	be changed.  When the user writes his own routine°°´³°	;	he need not worry about missing characters°°´´°	;	because the input part of this program is °°´µ°	;	interupt driven and will not miss characters due°°´¶°	;	to a time consuming routine.°°´·°	;°°´¸°	;	NOTE :°°´¹°	;	   The one exception to this is if the user has°°µ°°	;	to disable interupts for any reason (i.e. disk°°µ±°	;	I/O).  First the user must always remember to°°µ²°	;	restore interupts after his routine is finished°°µ³°	;	Second he should Send and XOFF to the host before°°µ´°	;	disabling interupts and then should wait a few°°µµ°	;	seconds for the last few characters to be°°µ¶°	;	received.  Then he may disable interupts and°°µ·°	;	execute the routine.  After the routine has°°µ¸°	;	executed and the interupts are restored the°°µ¹°	;	routine should send an XON to the host.°°¶°°	;°°¶±°	KBCHAR	EQU	002BH°°¶²°	PRCHAR	EQU	003BH°°¶³°	RSINIT	EQU	005AH°°¶´°	RSTX	EQU	0055H°°¶µ°	SLEEP	EQU	0060H°°¶¶°	RSRCV	EQU	0050H°°¶·°	KBBRK	EQU	028DH°°¶¸°	VDCLS	EQU	01C9H°°¶¹°	KBWAIT	EQU	0049H°°·°°	PRCHAR	EQU	003BH°°·±°	VDLINE	EQU	021BH°°·²°	VDCHAR	EQU	0033H°°·³°	RSUART	EQU	0EAH		;Uart port°°·´°	RSBUFF	EQU	0EBH		;RS232 I/O port°°·µ°	RSINTV	EQU	4207H		;RS232 interupt vector°°·¶°	IMPORT	EQU	0E0H°°··°	RSPORT	EQU	0E8H		;RS232 MASTER RESET°°·¸°	RSBRG	EQU	0E9H		;RS232 BAUD°°·¹°		ORG	7000H°°¸°°	PROBEG	EQU	$		;used to find program len°°¸±°	;°°¸²°	;°°¸³°	;	Beginning of program°°¸´°	;°°¸µ°	INIT	CALL	VDCLS°°¸¶°	;°°¸·°	;	RS232 initialization part°°¸¸°		LD	A,02H°°¸¹°		OUT	(RSPORT),A	;RESET RS232°°¹°°		LD	A,055H		;300 SEND/300 RECEIVE°°¹±°		OUT	(RSBRG),A	;set it°°¹²°		LD	A,96+0+8+4+2+1	;RS Parity,wordlen,etc°°¹³°		OUT	(RSUART),A°°¹´°		IN	A,(0E0H)	;Get current Int status°°¹µ°		LD	(SAVINT),A	;Save it.°°¹¶°		LD	A,20H		;RS232 Receive Interupts°°¹·°		OUT	(IMPORT),A	;SET IT°°¹¸°		LD	HL,IDENT°°¹¹°		CALL	VDLINE°±°°°		LD	A,15°±°±°		CALL	VDCHAR		;TURN CURSOR OFF°±°²°	;°±°³°		LD	HL,RSINT	;RS232 interupt handler°±°´°		LD	(RSINTV),HL	;Set it°±°µ°	LOOP	CALL	RSCHEK		;Go transmit char if rdy°±°¶°		LD	A,(BLINK)	;BLINK COUNTER°±°·°		DEC	A		;CHECK°±°¸°		LD	(BLINK),A	;SAVE IT°±°¹°		JP	NZ,KBIN°±±°°		LD	A,100D		;DELAY FOR CURSOR°±±±°		LD	(BLINK),A°±±²°		LD	A,(CURSOR)°±±³°		CP	0		;IS IT ON°±±´°		JP	Z,PTCRON	;PUT CURSOR ON°±±µ°		LD	A,(CURCHR)°±±¶°		LD	HL,(4020H)°±±·°		LD	(HL),A		;PUT CHR WHERE IT BELONGS°±±¸°		LD	A,0°±±¹°		LD	(CURSOR),A°±²°°		JP	KBIN°±²±°	PTCRON	LD	HL,(4020H)°±²²°		LD	A,(HL)		;GET CHAR°±²³°		LD	(CURCHR),A	;SAVE IT°±²´°		LD	(HL),95		;PUT UNDERLINE°±²µ°		LD	A,1°±²¶°		LD	(CURSOR),A°±²·°	KBIN	CALL	KBCHAR°±²¸°		CP	0°±²¹°		JP	Z,RSIN		;If nothing then continue°±³°°	;°±³±°	;	Special function part°±³²°	;	If <CLEAR> is press with another key°±³³°	;	Then the key is used as a special function key°±³´°	;	and 128 is added to it°±³µ°	;°±³¶°		EX	AF,AF'		;Save a°±³·°		LD	A,(3840H)	;Keyboard vector°±³¸°		BIT	1,A		;<CLEAR>?°±³¹°		JP	NZ,SPECIN	;Special char input°±´°°		EX	AF,AF'°±´±°		JP	KBCONT°±´²°	SPECIN	EX	AF,AF'°±´³°		SET	7,A		;IF clear then set bit 7°±´´°		CP	128+31		;Just clear + <CLEAR>°±´µ°		JP	Z,RSIN°±´¶°	KBCONT	CP	01H		;CTRL/A°±´·°		JP	Z,CTRLA		;GO SEE IF <BRK>°±´¸°		CP	31		;<CLEAR>°±´¹°		JP	Z,RSIN		;If so then go°±µ°°	;°±µ±°	;	The following code is for if the character°±µ²°	;	code in A is greater then 128°±µ³°	;	In this case the value is used as the index°±µ´°	;	for an array lookup table for a special function°±µµ°	;	to get the value in a to be added to 128°±µ¶°	;	the user presses <CLEAR> in conjunction with°±µ·°	;	other keys.  There are 127 different codes°±µ¸°	;	However all of them are not accessable from the°±µ¹°	;	keyboard.°±¶°°	;°±¶±°		CP	128		;>128°±¶²°		JP	M,SPCONT°±¶³°		AND	127		;Mask out bit 7°±¶´°		ADD	A,A		;A=A*2°±¶µ°		LD	L,A		;LD°±¶¶°		LD	H,0		;HL,A°±¶·°		LD	DE,SPCTBL	;Base address table°±¶¸°		ADD	HL,DE		;get array address°±¶¹°		LD	E,(HL)°±·°°		INC	HL°±·±°		LD	D,(HL)		;LD DE,(HL)°±·²°		LD	H,D°±·³°		LD	L,E		;LD HL,DE°±·´°		JP	(HL)		;Jump to the address°±·µ°	;°±·¶°	;	The following part looks up the°±··°	;	ascii code to send if it the°±·¸°	;	ascii code it got from the keyboard is in A°±·¹°	;	The new value will replace the old value in A°±¸°°	;°±¸±°	SPCONT	LD	E,A		;LD°±¸²°		LD	D,0		;DE,A°±¸³°		LD	HL,CHRTBL°±¸´°		ADD	HL,DE		;Compute array addr°±¸µ°		LD	A,(HL)		;Get new char°±¸¶°	;	Table lookup part end°±¸·°	TRNSMT	CALL	RSOUT°±¸¸°	;°±¸¹°	RSIN	LD	A,(IBFLEN)	;RS input buffer length°±¹°°		CP	0°±¹±°		JP	Z,LOOP°±¹²°		LD	A,(CURSOR)°±¹³°		CP	0		;If cursor is off°±¹´°		JP	Z,CUREND	;then don't take it off°±¹µ°	;°±¹¶°		LD	HL,(4020H)°±¹·°		LD	A,(CURCHR)	;GET CHAR AT CURSOR POS°±¹¸°		LD	(HL),A		;PUT IT BACK°±¹¹°		LD	A,0°²°°°		LD	(CURSOR),A	;CURSOR ON FLAG°²°±°	;°²°²°	;	RS232 input part (accually gets input from )°²°³°	;	input buffer°²°´°	CUREND	LD	A,(IBFLEN)	;Is the Buffer empty?°²°µ°		CP	0		;????°²°¶°		JP	Z,LOOP		;If so then go°²°·°		LD	DE,TOP°²°¸°		LD	HL,(OBUFFP)°²°¹°		OR	A		;Clear carry°²±°°		SBC	HL,DE		;HL=top of buffer°²±±°		JP	NZ,NOTOP1°²±²°		LD	HL,IBUFF°²±³°		LD	(OBUFFP),HL	;If we hit the top, loop°²±´°		JP	OBFCON		;Skip Output buffer loop°²±µ°	NOTOP1	LD	HL,(OBUFFP)	;Get Pointer addr°²±¶°		INC	HL		;Increment mem pointer°²±·°		LD	(OBUFFP),HL°²±¸°	OBFCON	LD	A,(HL)		;Get char from mem°²±¹°		EX	AF,AF'		;SAVE A°²²°°		LD	A,(IBFLEN)°²²±°		DEC	A°²²²°		LD	(IBFLEN),A°²²³°	;°²²´°		LD	A,(BFSTOP)	;Is the host XOFFed°²²µ°		CP	1°²²¶°		JP	NZ,BFNSTP	;If not then go°²²·°		LD	A,(IBFLEN)	;Get buffer len°²²¸°		CP	056 		;>=150°²²¹°		JP	NC,BFNSTP°²³°°		LD	A,11H		;XON°²³±°		CALL	RSSPEC		;XON the host°²³²°		LD	A,0°²³³°		LD	(BFSTOP),A	;Set flag to host on°²³´°	BFNSTP	EX	AF,AF'		;Get Character back°²³µ°		CP	0		;Is it null°²³¶°		JP	Z,LOOP		;If so then ignore it°²³·°		EX	AF,AF'		;Otherwise save A again°²³¸°		LD	A,(F155)°²³¹°		CP	0FFH		;Is this character an°²´°°		JP	Z,ESC155	;Escape sequence?°²´±°		EX	AF,AF'		;Get char back°²´²°	;°²´³°	;	Control interpreting part°²´´°	;°²´µ°		LD	(DISCHR),A	;Save character°²´¶°		CP	32		;A>=32°²´·°		JP	P,NOCTL		;No control code°²´¸°		CP	0		;A<0°²´¹°		JP	M,NOCTL		;No control code°²µ°°		SLA	A		;A=A*2°²µ±°		LD	E,A°²µ²°		LD	D,0		;LD DE,A°²µ³°		LD	HL,CTRTBL°²µ´°		ADD	HL,DE		;Get array addr°²µµ°		LD	E,(HL)°²µ¶°		INC	HL°²µ·°		LD	D,(HL)		;LD DE,(HL)°²µ¸°		LD	H,D°²µ¹°		LD	L,E		;LD HL,DE°²¶°°		JP	(HL)		;Go to routine°²¶±°	;°²¶²°	NOCTL	CP	155°²¶³°		JP	NZ,CONT1°²¶´°	FLG155	LD	A,0FFH		;Set 155 flag°²¶µ°		LD	(F155),A°²¶¶°		JP	LOOP°²¶·°	CONT1	CALL	VDCHAR°²¶¸°		LD	A,(PFLAG)°²¶¹°		CP	0°²·°°		JP	Z,LOOP°²·±°		CALL	HARDCP°²·²°		JP	LOOP°²·³°	;°²·´°	;	Control character routines°²·µ°	;	for characters 0-31°²·¶°	;°²··°	CR	LD	A,(16416)°²·¸°		AND	64+128°²·¹°		LD	(16416),A°²¸°°		JP	LOOP°²¸±°	BCKSPC	LD	A,(4020H)	;GET CURSOR ADDR°²¸²°		AND	63		;LOWER 5°²¸³°		CP	0		;IS IT ALREADY ZERO?°²¸´°		JP	Z,LOOP		;IF SO THEN GO°²¸µ°		DEC	A		;DECREMENT HORIZONTAL°²¸¶°		LD	B,A°²¸·°		LD	A,(4020H)	;GET BACK ORIGINAL°²¸¸°		AND	128+64		;MASK OUT 5 BITS°²¸¹°		OR	B		;PUT NEW 5 BITS IN°²¹°°		LD	(4020H),A	;SAVE IT°²¹±°		LD	A,(PFLAG)°²¹²°		CP	0		;Print off°²¹³°		JP	Z,LOOP°²¹´°		CALL	HARDCP°²¹µ°		JP	LOOP		;BACK TO BUINESS°²¹¶°	TAB	LD	HL,(4020H)	;Get cursor address°²¹·°		LD	A,L		;A= LSB of cursor°²¹¸°		AND	7		;Only first 3 bits°²¹¹°		LD	B,A		;Save it in B°³°°°		LD	A,8°³°±°		SUB	B		;How far from 8 is B°³°²°		LD	B,A		;Save count in B°³°³°		LD	C,A		;Save A°³°´°	TABLOP	LD	A,32		;Space°³°µ°		CALL	VDCHAR		;Output a space°³°¶°		DJNZ	TABLOP		;Continue till done°³°·°		LD	A,(PFLAG)°³°¸°		CP	0°³°¹°		JP	Z,LOOP		;If Printer off then skip°³±°°		LD	B,C		;Restore B°³±±°		LD	A,32°³±²°		LD	(DISCHR),A	;Store space to print°³±³°	TB1LOP	EXX			;Save B°³±´°		CALL	HARDCP°³±µ°		EXX			;Get B back°³±¶°		DJNZ	TB1LOP°³±·°		JP	LOOP		;Back to business.°³±¸°	;°³±¹°	;°³²°°	CTRLA	CALL	KBBRK°³²±°		JP	Z,AKEY		;Z=NO BREAK°³²²°		LD	A,03H		;CTRL/C°³²³°		JP	TRNSMT°³²´°	AKEY	LD	A,1		;CTRL/A°³²µ°		JP	TRNSMT°³²¶°	LNFEED	LD	DE,(4020H)	;CHECK°³²·°		LD	HL,3FADH	;BEG OF LAST LINE -1°³²¸°		XOR	A		;ZERO FLAGS°³²¹°		SBC	HL,DE		;CP EM°³³°°		JP	P,LNCONT°³³±°	;	SCROLL ROUTINE°³³²°		LD	HL,3C00H+40H	;BEG OF 2ND LINE°³³³°		LD	DE,3C00H	;1ST LN°³³´°		LD	BC,400H-40H	;1K-1LN°³³µ°		LDIR			;SCROLL IT°³³¶°		LD	HL,3FC0H	;NOW°³³·°		LD	DE,3FC1H	;ZERO LAST°³³¸°		LD	BC,3FH		;LINE°³³¹°		LD	(HL),20H	;STORE A SPACE°³´°°		LDIR			;ZERO IT°³´±°		LD	A,(PFLAG)	;Printer on°³´²°		CP	0°³´³°		JP	Z,LOOP°³´´°		CALL	HARDCP		;If on then print it°³´µ°		JP	LOOP°³´¶°	LNCONT	LD	A,1AH		;DN LNFEED°³´·°		CALL	VDCHAR°³´¸°		LD	A,(PFLAG)°³´¹°		CP	0°³µ°°		JP	Z,LOOP°³µ±°		CALL	HARDCP°³µ²°		JP	LOOP°³µ³°	;°³µ´°	;°³µµ°	;	Special RS-232C output routine°³µ¶°	;	does not put in buffer°³µ·°	;	transmits it immediately°³µ¸°	;	used for control characters (XON/XOFF)°³µ¹°	;°³¶°°	RSSPEC	PUSH	AF		;Save AF°³¶±°	RSSPLP	IN	A,(RSUART)	;Get ready status°³¶²°		AND	40H		;Ready to TX°³¶³°		JP	Z,RSSPLP	;Loop til Ready°³¶´°		POP	AF		;Get back char°³¶µ°		OUT	(RSBUFF),A	;Transmit it°³¶¶°		RET			;Back to business°³¶·°	;°³¶¸°	;	RS-232C output routine°³¶¹°	;°³·°°	RSOUT	LD	HL,(OBUFIP)	;Get next location to use°³·±°		LD	(HL),A		;Save character in que°³·²°		EX	AF,AF'		;Save it again°³·³°		LD	DE,OBUFF+255	;End of output buffer°³·´°		OR	A		;Clear carry°³·µ°		SBC	HL,DE		;CP HL,DE°³·¶°		JP	NZ,ROCONT;If not then skip°³··°		LD	HL,OBUFF	;Wrap around to beg°³·¸°		LD	(OBUFIP),HL	;Save it°³·¹°		JP	ROPCNT		;Continue°³¸°°	ROCONT	LD	HL,(OBUFIP)	;Get current pointer°³¸±°		INC	HL		;Increment pointer°³¸²°		LD	(OBUFIP),HL	;Save it°³¸³°	ROPCNT	LD	A,(OBUFLN)	;Get length°³¸´°		INC	A		;Increment it°³¸µ°		LD	(OBUFLN),A	;Save it°³¸·°	;°³¸¸°	;°³¸¹°	RSCHEK	LD	A,(OBUFLN)	;Get buffer length°³¹°°		CP	0		;Nothing in it°³¹±°		RET	Z		;If so then go°³¹²°	;°³¹³°	;	Now check to see if Host Previously XOFFed us°³¹´°	;°³¹µ°	CHKXOF	LD	A,(HSTXOF)	;Are we XOFFed°³¹¶°		CP	0		;????°³¹·°		JP	Z,RSOK		;If not then go°³¹¸°	;	If we are XOFFed then check to see if buff is full°³¹¹°		LD	A,(OBUFLN)	;Get buffer length°´°°°		CP	250		;Buffer full°´°±°		JP	Z,CHKXOF	;If so then keep looping°´°²°		RET			;Otherwise skip output°´°³°	;°´°´°	;	Actual transmitting part°´°µ°	;°´°¶°	RSOK	IN	A,(RSUART)		;Get Ready statis°´°·°		AND	40H			;Ready to TX°´°¸°		JP	Z,SKPOUT	;Skip output°´°¹°		LD	HL,(OBUFOP)	;Get nxt char to send°´±°°		LD	A,(HL)		;Get nxt char°´±±°		OUT	(RSBUFF),A	;Transmit it°´±²°		LD	DE,OBUFF+255	;HL at end yet?°´±³°		XOR	A		;Clear carry°´±´°		SBC	HL,DE		;Is HL=DE°´±µ°		JP	NZ,NOBTOP	;No Output Buffer TOP°´±¶°		LD	HL,OBUFF	;Account for Future INC°´±·°		LD	(OBUFOP),HL	;Reset pointer°´±¸°		JP	OBRCNT°´±¹°	NOBTOP	LD	HL,(OBUFOP)	;Get output pointer°´²°°		INC	HL		;Increment it°´²±°		LD	(OBUFOP),HL	;Save it°´²²°	OBRCNT	LD	A,(OBUFLN)	;Get length°´²³°		DEC	A		;Length=length-1°´²´°		LD	(OBUFLN),A	;Save it°´²µ°		RET			;Back to business°´²¶°	SKPOUT	LD	A,(OBUFLN)	;Get buffer length°´²·°		CP	255		;is it full°´²¸°		RET	NZ		;If not then return°´²¹°		JP	RSCHEK		;Go wait till ready°´³°°	;°´³±°	;°´³²°	;	RS232 interupt handler°´³³°	;	When a character is received into the RS232°´³´°	;	it generates an interupt which transfers the°´³µ°	;	processor to this routine°´³¶°	;°´³·°	RSINT	PUSH	AF°´³¸°		PUSH	DE°´³¹°		PUSH	HL		;Push all registers°´´°°		IN	A,(RSBUFF)	;Get character°´´±°	;	Buffer Storing Part FIFO circular buffer°´´²°	;	°´´³°	;	Check for XON or XOFF°´´´°	;°´´µ°		CP	19		;XOFF?°´´¶°		JP	Z,INTXOF	;If so then go°´´·°		CP	17		;XON°´´¸°		JP	Z,INTXON	;If so then go°´´¹°		LD	DE,TOP°´µ°°		LD	HL,(IBUFFP)°´µ±°		OR	A		;Clear carry flag°´µ²°		SBC	HL,DE		;CP HL,DE°´µ³°		JP	NZ,NOTOP	;Not at top?°´µ´°		LD	HL,IBUFF°´µµ°		LD	(IBUFFP),HL	;Move pointer to beg.°´µ¶°		JP	SKINC°´µ·°	NOTOP	LD	HL,(IBUFFP)°´µ¸°		INC	HL°´µ¹°		LD	(IBUFFP),HL	;Save buffer°´¶°°	SKINC	LD	(HL),A		;Store character to mem°´¶±°		LD	A,(IBFLEN)	;Get input length°´¶²°		INC	A°´¶³°		LD	(IBFLEN),A	;Increment it and save it°´¶´°		CP	200		;if it's >=200 then stop°´¶µ°		JP	C,RSIRET	;If not then continue°´¶¶°		LD	A,(BFSTOP)	;Are we already XOFFed°´¶·°		CP	0		;1 = Yes°´¶¸°		JP	NZ,RSIRET	;If so then don't reXOFF°´¶¹°		LD	A,19D		;CTRL/S°´·°°		CALL	RSSPEC		;Transmit it°´·±°		LD	A,1°´·²°		LD	(BFSTOP),A	;Set flag to bfr stopped°´·³°	RSIRET	POP	HL°´·´°		POP	DE°´·µ°		POP	AF°´·¶°		RET			;Return to system°´··°	;°´·¸°	;°´·¹°	INTXOF	LD	A,1		;Host XOFFed us°´¸°°		LD	(HSTXOF),A	;Save flag°´¸±°		JP	RSIRET		;Go back°´¸²°	INTXON	LD	A,0		;Host XONed us°´¸³°		LD	(HSTXOF),A	;Save flag°´¸´°		JP	RSIRET°´¸µ°	;°´¸¶°	;°´¸·°	;°´¸¸°	°´¸¹°	ESC155	LD	A,(DCAF)	;GET FLAG FOR DCA°´¹°°		CP	0		;IS IT ON°´¹±°		JP	NZ,DCAGET	;IF SO THEN GO°´¹²°		EX	AF,AF'°´¹³°	;°´¹´°	;	Table lookup for special function°´¹µ°	;°´¹¶°		CP	'A'°´¹·°		JP	M,CLR155	;Only°´¹¸°		CP	'Z'+1°´¹¹°		JP	P,CLR155	;Valid characters°µ°°°	;°µ°±°		SUB	65		;Start at 0°µ°²°		ADD	A,A		;Double a for word tbl°µ°³°		LD	E,A°µ°´°		LD	D,0		;LD DE,A°µ°µ°		LD	HL,ESCTBL°µ°¶°		ADD	HL,DE		;COMPUTE ADDRESS°µ°·°		LD	E,(HL)°µ°¸°		INC	HL°µ°¹°		LD	D,(HL)		;LD HL,(DE)°µ±°°		EX	DE,HL		;Put DE into HL°µ±±°		JP	(HL)		;Jump to function°µ±²°	;°µ±³°	;°µ±´°	HOME	LD	A,1CH°µ±µ°		CALL	VDCHAR°µ±¶°		JP	CLR155°µ±·°	CLRTBT	LD	A,1FH°µ±¸°		CALL	VDCHAR°µ±¹°		JP	CLR155°µ²°°	CLRTEL	LD	A,1EH°µ²±°		CALL	VDCHAR°µ²²°		JP	CLR155°µ²³°	UPCOM	LD	HL,(4020H)	;GET CURSOR ADDR°µ²´°		LD	DE,3C00H+64	;1ST CHAR ON SECOND LINE°µ²µ°		SBC	HL,DE°µ²¶°		JP	M,CLR155	;IF ON 1ST LINE IGNORE°µ²·°		LD	A,1BH		;OTHERWISE DO IT°µ²¸°		CALL	VDCHAR°µ²¹°		JP	CLR155°µ³°°	DCOM	LD	HL,3FAEH	;BEGIN OF 16 LINE -1°µ³±°		LD	DE,(4020H)	;CSR ADDR°µ³²°		SBC	HL,DE°µ³³°		JP	M,CLR155	;IF ON 16TH LINE IGNORE°µ³´°		LD	A,1AH°µ³µ°		CALL	VDCHAR°µ³¶°		JP	CLR155°µ³·°	LCOM	LD	A,(4020H)°µ³¸°		AND	63		;MASK OUT UP 2 BITS°µ³¹°		CP	0		;IS IT ZERO°µ´°°		
P	Z,CLR155	;IF IT IS THEN SKIP°µ´±°		LD	A,18H°µ´²°		CALL	VDCHAR°µ´³°		JP	CLR155°µ´´°	RCOM	LD	A,(4020H)°µ´µ°		AND	63		;ONLY LOWER 6 BITS°µ´¶°		CP	63		;IT AT END OF SCRN°µ´·°		JP	Z,CLR155	;IF SO THEN GO°µ´¸°		LD	A,19H°µ´¹°		CALL	VDCHAR°µµ°°		JP	CLR155°µµ±°	;°µµ²°	DCA	LD	A,1°µµ³°		LD	(DCAF),A	;SET DCA FLAG TO ON°µµ´°		LD	(DCAXY),A	;SET X,Y FLAG TO Y°µµµ°		JP	LOOP		;GO BACK°µµ¶°	;°µµ·°	DCAGET	LD	A,(DCAXY)	;GET X,Y FLAG°µµ¸°		CP	0		;IS IT X°µµ¹°		JP	NZ,DCAY		;IF NOT THEN GO Y°µ¶°°	DCAX	EX	AF,AF'		;Get char°µ¶±°		SUB	32		;OFFSET°µ¶²°		CP	0		;<0°µ¶³°		JP	M,DCANCX	;NO CHANGE FOR X°µ¶´°		CP	65		;>64°µ¶µ°		JP	P,DCANCX	;IF SO THEN GO°µ¶¶°		LD	HL,(NCURSR)°µ¶·°		LD	E,A°µ¶¸°		LD	D,0°µ¶¹°		ADD	HL,DE		;COMPUTE NEW CURSOR ADDR°µ·°°		LD	(4020H),HL	;SET NEW CURSOR ADDR°µ·±°		LD	A,0°µ·²°		LD	(DCAF),A°µ·³°		JP	CLR155°µ·´°	DCANCX	JP	CLR155°µ·µ°	DCAY	EX	AF,AF'		;Get char°µ·¶°		SUB	32		;OFFSET°µ··°		CP	0		;<0°µ·¸°		JP	M,NDCACY	;N CHANGE Y°µ·¹°		CP	16		;<15°µ¸°°		JP	P,NDCACY°µ¸±°		LD	DE,3C00H	;BASE ADDR°µ¸²°		LD	L,A		;LD HL°µ¸³°		LD	H,0		;WITH A°µ¸´°		ADD	HL,HL°µ¸µ°		ADD	HL,HL°µ¸¶°		ADD	HL,HL°µ¸·°		ADD	HL,HL°µ¸¸°		ADD	HL,HL°µ¸¹°		ADD	HL,HL		;HL=HL*6°µ¹°°		ADD	HL,DE		;COMPUTE PARTIAL ADDR°µ¹±°		LD	(NCURSR),HL	;SAVE PARTIAL ADDR°µ¹²°	NDCACY	LD	A,0°µ¹³°		LD	(DCAXY),A	;SET X,Y FLAG TO X°µ¹´°		JP	LOOP°µ¹µ°	;°µ¹¶°	;°µ¹·°	;	Reverse line feed routine°µ¹¸°	;	Invoked by 155/I°µ¹¹°	;	If not on first line will just move cursor°¶°°°	;	up vertically.  If on first line°¶°±°	;	Moves every character on the screen°¶°²°	;	down 1 line and then clears the 1st line.°¶°³°	;°¶°´°	RLNFED	LD	HL,(4020H)		;Get cursor addr°¶°µ°		LD	DE,3C40H		;Beg of 2nd ln°¶°¶°		XOR	A°¶°·°		SBC	HL,DE			;CP HL,DE°¶°¸°		JP	P,NSCROL		;If > 1st ln go°¶°¹°		LD	HL,3FFFH-64		;From 2nd lst ln°¶±°°		LD	DE,3FFFH		;To last line°¶±±°		LD	BC,400H-40H		;1K-1line°¶±²°		LDDR				;Scroll it°¶±³°		LD	HL,3C00H		;Zero first line°¶±´°		LD	(HL),20H		;With blanks°¶±µ°		LD	DE,3C01H		;To here°¶±¶°		LD	BC,3FH			;1 line-1°¶±·°		LDIR				;Clear it°¶±¸°		JP	CLR155°¶±¹°	NSCROL	LD	A,1BH			;Up ln feed°¶²°°		CALL	VDCHAR			;Print it°¶²±°		JP	CLR155°¶²²°	CLR155	XOR	A°¶²³°		LD	(F155),A°¶²´°		JP	LOOP°¶²µ°	°¶²¶°	PNTON	LD	A,0FFH°¶²·°		LD	(PFLAG),A°¶²¸°		JP	RSIN°¶²¹°	PNTOFF	LD	A,00H°¶³°°		LD	(PFLAG),A°¶³±°		JP	RSIN°¶³²°	PNTZER	LD	HL,BUFFER°¶³³°		LD	(PBUFF),HL	;Set pointer to init val°¶³´°		JP	RSIN°¶³µ°	;°¶³¶°	;	Routine to make printer print normal font°¶³·°	;°¶³¸°	NORPRT	LD	A,30D		;Normal font°¶³¹°		CALL	PRCHAR		;Print it°¶´°°		JP	RSIN°¶´±°	;°¶´²°	;	Routine to make printer print compressed font°¶´³°	;°¶´´°	SMLPRT	LD	A,29D		;Compressed font°¶´µ°		CALL	PRCHAR		;Print it°¶´¶°		JP	RSIN		;Back to business°¶´·°	;°¶´¸°	;	Quitting routine°¶´¹°	;°¶µ°°	QUIT	LD	A,(SAVINT)°¶µ±°		RES	4,A		;Reset 16 bit°¶µ²°		OUT	(0E0H),A	;Restore Proper Interupts°¶µ³°		JP	402DH		;Jump to TRSDOS°¶µ´°	;°¶µµ°	HARDCP	LD	A,(DISCHR)	;Get char from host°¶µ¶°		LD	HL,(PBUFF)	;Get buff byte addr°¶µ·°		CP	08		;Backspace?°¶µ¸°		JP	NZ,HCONT°¶µ¹°		LD	DE,BUFFER	;Is HL=buffer°¶¶°°		XOR	A		;Reset carry°¶¶±°		SBC	HL,DE		;Is HL=DE°¶¶²°		RET	Z		;If so then don't bkspc°¶¶³°		LD	HL,(PBUFF)	;Get pointer again°¶¶´°		DEC	HL		;Point to previous mem°¶¶µ°		LD	(PBUFF),HL°¶¶¶°		RET°¶¶·°	HCONT	LD	(HL),A		;Put it in buffer°¶¶¸°		INC	HL		;INC buffer addr°¶¶¹°		LD	(PBUFF),HL	;Save it°¶·°°		LD	DE,BUFFER+1023	;1K print buffer°¶·±°		SBC	HL,DE		;Buffer full yet?°¶·²°		JP	Z,BUFDMP°¶·³°		RET°¶·´°	;°¶·µ°	;	Buffer dump routine°¶·¶°	;	Dumps entire print buffer to printer°¶··°	;	assumes host has an XOFF/XON function°¶·¸°	;°¶·¹°	DMPBUF	LD	HL,(PBUFF)	;Next address°¶¸°°		LD	DE,BUFFER°¶¸±°		SBC	HL,DE		;Get num of bytes°¶¸²°		RET	Z		;If nothing then ret°¶¸³°		LD	B,H°¶¸´°		LD	C,L		;LD BC WITH HL°¶¸µ°		LD	HL,BUFFER°¶¸¶°	DMPLOP	LD	A,(HL)°¶¸·°		CALL	PRCHAR		;Print it°¶¸¸°		INC	HL		;Point to next char°¶¸¹°		DEC	BC°¶¹°°		LD	A,B°¶¹±°		OR	C		;BC=0?°¶¹²°		JP	NZ,DMPLOP°¶¹³°		LD	HL,BUFFER°¶¹´°		LD	(PBUFF),HL	;Zero buffer°¶¹µ°		RET°¶¹¶°	;°¶¹·°	;°¶¹¸°	BUFDMP	CALL	DMPBUF°¶¹¹°		JP	LOOP°·°°°	;°·°±°	;°·°²°	;	GO TO DEBUG ROUTINE (Temporary)°·°³°	;°·°´°	DEBUG	RST	30H°·°µ°	;°·°¶°	;°·°·°	;°·°¸°	;	Character table°·°¹°	;	This table contains the characters°·±°°	;	this program will send upon getting°·±±°	;	the index value from the keyboard.°·±²°	;	this table starts at a value of 1°·±³°	;°·±´°	CHRTBL	DEFB	00		;Dummy byte for zero°·±µ°		DEFB	01H		;CTRL/A°·±¶°		DEFB	02H		;CTRL/B°·±·°		DEFB	03H		;CTRL/C°·±¸°		DEFB	04°·±¹°		DEFB	05°·²°°		DEFB	06°·²±°		DEFB	07°·²²°		DEFB	127	;Change Backspace to <DEL>°·²³°		DEFB	09°·²´°		DEFB	10°·²µ°		DEFB	11°·²¶°		DEFB	12°·²·°		DEFB	13°·²¸°		DEFB	14°·²¹°		DEFB	15°·³°°		DEFB	16°·³±°		DEFB	17°·³²°		DEFB	18°·³³°		DEFB	19°·³´°		DEFB	20°·³µ°		DEFB	21°·³¶°		DEFB	22°·³·°		DEFB	23°·³¸°		DEFB	08	;Shift backarrow for BCKSPC4°·³¹°		DEFB	95	;Change shift tab to Underline°·´°°		DEFB	26°·´±°		DEFB	27°·´²°		DEFB	00°·´³°		DEFB	00°·´´°		DEFB	00°·´µ°		DEFB	00°·´¶°		DEFB	32		;Space°·´·°		DEFB	'!'°·´¸°		DEFB	'"'°·´¹°		DEFB	'#'°·µ°°		DEFB	'$'°·µ±°		DEFB	'%'°·µ²°		DEFB	'&'°·µ³°		DEFB	39		;Single quote°·µ´°		DEFB	'('°·µµ°		DEFB	')'°·µ¶°		DEFB	'*'°·µ·°		DEFB	'+'°·µ¸°		DEFB	','°·µ¹°		DEFB	'-'°·¶°°		DEFB	'.'°·¶±°		DEFB	'/'°·¶²°		DEFB	'0'°·¶³°		DEFB	'1'°·¶´°		DEFB	'2'°·¶µ°		DEFB	'3'°·¶¶°		DEFB	'4'°·¶·°		DEFB	'5'°·¶¸°		DEFB	'6'°·¶¹°		DEFB	'7'°··°°		DEFB	'8'°··±°		DEFB	'9'°··²°		DEFB	':'°··³°		DEFB	';'°··´°		DEFB	'<'°··µ°		DEFB	'='°··¶°		DEFB	'>'°···°		DEFB	'?'°··¸°		DEFB	'@'°··¹°		DEFM	'ABCDEFGHIJKLMNOPQRSTUVWXYZ'°·¸°°		;	I didn't want to type all those DEFB's°·¸±°		DEFB	94	;Change uparrow to Ascii up arrow°·¸²°		DEFB	0°·¸³°		DEFB	00°·¸´°		DEFB	00°·¸µ°		DEFB	00	;Non keyboard characters°·¸¶°		DEFB	92	;Shift '@' to Backslash°·¸·°		DEFM	'abcdefghijklmnopqrstuvwxyz'°·¸¸°		;	I got lazy again.°·¸¹°		DEFB	123	;Squiggly left bracket°·¹°°		DEFB	124	;Vertical line°·¹±°		DEFB	125	;Squiggly right bracket°·¹²°		DEFB	126	;Tilde°·¹³°		DEFB	00	;Non keyboard°·¹´°	;°·¹µ°	;	End of keyboard character translation table°·¹¶°	;°·¹·°	;°·¹¸°	;°·¹¹°	;	Special function key jump addresses°¸°°°	;	whenever a key is pressed in conjunction°¸°±°	;	with <CLEAR> it's value is increased°¸°²°	;	by 128.  Whenever the keyboard routine°¸°³°	;	gets a character above 128, it will°¸°´°	;	jump to the nth address in this table°¸°µ°	;	this table has a dummy first jump°¸°¶°	;	to take the place of zero°¸°·°	;°¸°¸°	SPCTBL	DEFW	0000		;Dummy word°¸°¹°		DEFW	RSIN°¸±°°		DEFW	RSIN		;CTRL/B°¸±±°		DEFW	RSIN°¸±²°		DEFW	RSIN°¸±³°		DEFW	RSIN°¸±´°		DEFW	RSIN°¸±µ°		DEFW	RSIN		;CTRL/G/<CLEAR>°¸±¶°		DEFW	RSIN°¸±·°		DEFW	RSIN°¸±¸°		DEFW	RSIN°¸±¹°		DEFW	RSIN°¸²°°		DEFW	RSIN°¸²±°		DEFW	RSIN°¸²²°		DEFW	RSIN°¸²³°		DEFW	RSIN°¸²´°		DEFW	RSIN		;CTRL/P/<CLEAR>°¸²µ°		DEFW	RSIN°¸²¶°		DEFW	RSIN°¸²·°		DEFW	RSIN°¸²¸°		DEFW	RSIN°¸²¹°		DEFW	RSIN°¸³°°		DEFW	RSIN°¸³±°		DEFW	RSIN°¸³²°		DEFW	RSIN°¸³³°		DEFW	RSIN°¸³´°		DEFW	RSIN		;CTRL/Z/<CLEAR>°¸³µ°		DEFW	RSIN°¸³¶°		DEFW	RSIN°¸³·°		DEFW	RSIN°¸³¸°		DEFW	RSIN°¸³¹°		DEFW	RSIN		;31°¸´°°		DEFW	RSIN°¸´±°		DEFW	RSIN°¸´²°		DEFW	RSIN°¸´³°		DEFW	RSIN°¸´´°		DEFW	RSIN°¸´µ°		DEFW	RSIN		;37°¸´¶°		DEFW	RSIN		;&°¸´·°		DEFW	RSIN		;'°¸´¸°		DEFW	RSIN		;(°¸´¹°		DEFW	RSIN		;)°¸µ°°		DEFW	RSIN		;*°¸µ±°		DEFW	RSIN		;+°¸µ²°		DEFW	RSIN		;,°¸µ³°		DEFW	RSIN		;-°¸µ´°		DEFW	RSIN		;.°¸µµ°		DEFW	RSIN		;/°¸µ¶°		DEFW	RSIN		;0°¸µ·°		DEFW	RSIN		;1°¸µ¸°		DEFW	RSIN		;2°¸µ¹°		DEFW	RSIN		;3°¸¶°°		DEFW	RSIN		;4°¸¶±°		DEFW	RSIN		;5°¸¶²°		DEFW	RSIN		;6°¸¶³°		DEFW	RSIN		;7°¸¶´°		DEFW	RSIN		;8°¸¶µ°		DEFW	RSIN		;9°¸¶¶°		DEFW	RSIN		;:°¸¶·°		DEFW	RSIN		;";"°¸¶¸°		DEFW	RSIN		;<°¸¶¹°		DEFW	RSIN		;=°¸·°°		DEFW	RSIN		;>°¸·±°		DEFW	RSIN		;?°¸·²°		DEFW	RSIN		;@°¸·³°		DEFW	PNTON		;A Enable printer°¸·´°		DEFW	PNTOFF		;B Disable printer°¸·µ°		DEFW	PNTZER		;C Zero print buffer°¸·¶°		DEFW	DEBUG		;D go back to debug°¸··°		DEFW	RSIN		;E°¸·¸°		DEFW	RSIN		;F°¸·¹°		DEFW	RSIN		;G°¸¸°°		DEFW	RSIN		;H°¸¸±°		DEFW	RSIN		;I°¸¸²°		DEFW	RSIN		;J°¸¸³°		DEFW	RSIN		;K°¸¸´°		DEFW	RSIN		;L°¸¸µ°		DEFW	RSIN		;M°¸¸¶°		DEFW	NORPRT		;Normal print format°¸¸·°		DEFW	RSIN		;O°¸¸¸°		DEFW	BUFDMP		;P Dump print buffer cmd°¸¸¹°		DEFW	QUIT		;Q°¸¹°°		DEFW	RSIN		;R°¸¹±°		DEFW	SMLPRT		;Small print format°¸¹²°		DEFW	RSIN		;T°¸¹³°		DEFW	RSIN		;U°¸¹´°		DEFW	RSIN		;V°¸¹µ°		DEFW	RSIN		;W°¸¹¶°		DEFW	RSIN		;X°¸¹·°		DEFW	RSIN		;Y°¸¹¸°		DEFW	RSIN		;Z°¸¹¹°		DEFW	RSIN		;UP arrow°¹°°°		DEFW	RSIN		;Non keyboard character°¹°±°		DEFW	RSIN		;	"°¹°²°		DEFW	RSIN		;	"°¹°³°		DEFW	RSIN		;	"°¹°´°		DEFW	RSIN		;SHIFT @°¹°µ°		DEFW	PNTON		;a Enable printer°¹°¶°		DEFW	PNTOFF		;b Disable printer°¹°·°		DEFW	PNTZER		;c Zero printer buffer°¹°¸°		DEFW	DEBUG		;d Go back to debug°¹°¹°		DEFW	RSIN		;e°¹±°°		DEFW	RSIN		;f°¹±±°		DEFW	RSIN		;g°¹±²°		DEFW	RSIN		;h°¹±³°		DEFW	RSIN		;i°¹±´°		DEFW	RSIN		;j°¹±µ°		DEFW	RSIN		;k°¹±¶°		DEFW	RSIN		;l°¹±·°		DEFW	RSIN		;m°¹±¸°		DEFW	NORPRT		;Normal print format°¹±¹°		DEFW	RSIN		;o°¹²°°		DEFW	BUFDMP		;p Dump print buffer cmd°¹²±°		DEFW	QUIT		;q°¹²²°		DEFW	RSIN		;r°¹²³°		DEFW	SMLPRT		;Small print format°¹²´°		DEFW	RSIN		;t°¹²µ°		DEFW	RSIN		;u°¹²¶°		DEFW	RSIN		;v°¹²·°		DEFW	RSIN		;w°¹²¸°		DEFW	RSIN		;x°¹²¹°		DEFW	RSIN		;y°¹³°°		DEFW	RSIN		;z°¹³±°		DEFW	0000°¹³²°		DEFW	0000°¹³³°		DEFW	0000°¹³´°		DEFW	0000°¹³µ°		DEFW	0000		;Non-keyboard chars°¹³¶°	;°¹³·°	;	End of special function key table°¹³¸°	;°¹³¹°	;	Special function table°¹´°°	;	Special function are invoked by°¹´±°	;	sending a 155D to the terminal°¹´²°	;	followed by a character°¹´³°	;	the characters are A-Z°¹´´°	;	The table starts at A°¹´µ°	;°¹´¶°	ESCTBL	DEFW	UPCOM		;ESC A°¹´·°		DEFW	DCOM		;ESC B°¹´¸°		DEFW	RCOM		;ESC C°¹´¹°		DEFW	LCOM		;ESC D°¹µ°°		DEFW	CLR155		;ESC E Undefined°¹µ±°		DEFW	CLR155		;ESC F Not implemented°¹µ²°		DEFW	CLR155		;ESC G Not implemented°¹µ³°		DEFW	HOME		;ESC H°¹µ´°		DEFW	RLNFED		;ESC I Reverse line feed°¹µµ°		DEFW	CLRTBT		;ESC J Clear - end of scn°¹µ¶°		DEFW	CLRTEL		;ESC K Clear - end of lne°¹µ·°		DEFW	CLR155		;ESC L Undefined°¹µ¸°		DEFW	CLR155		;ESC M Undefined°¹µ¹°		DEFW	CLR155		;ESC N Undefined°¹¶°°		DEFW	CLR155		;ESC O Undefined°¹¶±°		DEFW	CLR155		;ESC P Undefined°¹¶²°		DEFW	CLR155		;ESC Q Undefined°¹¶³°		DEFW	CLR155		;ESC R Undefined°¹¶´°		DEFW	CLR155		;ESC S Undefined°¹¶µ°		DEFW	CLR155		;ESC T Undefined°¹¶¶°		DEFW	CLR155		;ESC U Undefined°¹¶·°		DEFW	CLR155		;ESC V Undefined°¹¶¸°		DEFW	CLR155		;ESC W Undefined°¹¶¹°		DEFW	CLR155		;ESC X Undefined°¹·°°		DEFW	DCA		;ESC Y (DCA) Y+32,X+32°¹·±°		DEFW	CLR155		;ESC Z Identification°¹·²°	;°¹·³°	;°¹·´°	;	Control code table°¹·µ°	;	This table is for characters °¹·¶°	;	0-31°¹··°	;	It gives the routine to Jump to°¹·¸°	;	when the program receives that character°¹·¹°	;	be ignored.  The table is 32 bytes long.°¹¸°°	;°¹¸±°	CTRTBL	DEFW	LOOP	;0  Ignore this°¹¸²°		DEFW	LOOP	;1  Ignore this°¹¸³°		DEFW	LOOP	;2  Ignore this°¹¸´°		DEFW	LOOP	;3  Ignore this°¹¸µ°		DEFW	LOOP	;4  Ignore this°¹¸¶°		DEFW	LOOP	;5  Ignore this°¹¸·°		DEFW	LOOP	;6  Ignore this°¹¸¸°		DEFW	LOOP	;7  Ignore this°¹¸¹°		DEFW	BCKSPC	;8  Backspace°¹¹°°		DEFW	TAB	;9  Tab°¹¹±°		DEFW	LNFEED	;10 Line feed°¹¹²°		DEFW	LOOP	;11 Ignore this°¹¹³°		DEFW	LOOP	;12 Ignore this°¹¹´°		DEFW	CR	;13 Carriage return°¹¹µ°		DEFW	LOOP	;14 Ignore this°¹¹¶°		DEFW	LOOP	;15 Ignore this°¹¹·°		DEFW	LOOP	;16 Ignore this°¹¹¸°		DEFW	LOOP	;17 Ignore this°¹¹¹°		DEFW	LOOP	;18 Ignore this±°°°°		DEFW	LOOP	;19 Ignore this±°°±°		DEFW	LOOP	;20 Ignore this±°°²°		DEFW	LOOP	;21 Ignore this±°°³°		DEFW	LOOP	;22 Ignore this±°°´°		DEFW	LOOP	;23 Ignore this±°°µ°		DEFW	LOOP	;24 Ignore this±°°¶°		DEFW	LOOP	;25 Ignore this±°°·°		DEFW	LOOP	;26 Ignore this±°°¸°		DEFW	FLG155	;27 Ignore this±°°¹°		DEFW	LOOP	;28 Ignore this±°±°°		DEFW	LOOP	;29 Ignore this±°±±°		DEFW	LOOP	;30 Ignore this±°±²°		DEFW	LOOP	;31 Ignore this±°±³°	;±°±´°	;	End of control code jump table±°±µ°	;±°±¶°	;±°±·°	;±°±¸°	;±°±¹°	;	Data Storage and constants±°²°°	;±°²±°	IDENT	DEFM	'VT52 Emulator by John C. Orlowski'±°²²°		DEFM	' VER 1.1'±°²³°		DEFB	0AH±°²´°		DEFM	'Copyright (c) 1983 by John C. Orlowski'±°²µ°		DEFB	0DH±°²¶°	F155	DEFB	00H		;Nxt chr esc seq flag±°²·°	CURCHR	DEFB	00		;To be toggled..±°²¸°	PFLAG	DEFB	00		;Print ON/OFF flag±°²¹°	PBUFF	DEFW	BUFFER		;Address of printer buff±°³°°	CURSOR	DEFB	00		;Cursor on/Off flag±°³±°	BLINK	DEFB	100D		;Cursor blink delay±°³²°	DCAF	DEFB	00		;DCA ON flag±°³³°	DCAXY	DEFB	00		;DCA variable±°³´°	NCURSR	DEFW	0000H		;Cursor address±°³µ°	RSCHAR	DEFB	00H		;Last character received±°³¶°	DISCHR	DEFB	00H		;Last character displayed±°³·°	SAVINT	DEFB	00H		;To save Interrupt status±°³¸°	IBUFF	DEFS	256±°³¹°	TOP	EQU	IBUFF+255	;Top of buffer±°´°°	IBUFFP	DEFW	IBUFF	;Input buffer pointer±°´±°	OBUFFP	DEFW	IBUFF	;Input buffer out pointer±°´²°	IBFLEN	DEFB	00H±°´³°	BFSTOP	DEFB	00H	;Host XOFFed flag±°´´°	OBUFF	DEFS	256	;Output buffer±°´µ°	OBUFIP	DEFW	OBUFF	;Output buffer input pointer±°´¶°	OBUFOP	DEFW	OBUFF   ;Output buffer output pointer±°´·°	OBUFLN	DEFB	00	;Output buffer length±°´¸°	HSTXOF	DEFB	00	;Host XOFFed flag±°´¹°	BUFFER	DEFB	00	;Start of print buffer±°µ°°	PROLEN	EQU	$-PROBEG ;Program length±°µ±°		END	INIT±°µ²°	;±°µ³°	;	End of VT52 Emulator±°µ´°	;	Whew,  Thats a long program!±°µµ°	;